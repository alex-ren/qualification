@inproceedings{Wadler1990Linear,
    abstract = {{The linear logic of J.-Y. Girard suggests a new type system for functional
languages, one which supports operations that "change the world". Values belonging
to a linear type must be used exactly once: like the world, they cannot be
duplicated or destroyed. Such values require no reference counting or garbage collection,
and safely admit destructive array update. Linear types extend Schmidt's
notion of single threading; provide an alternative to Hudak and Bloss' update
analysis; and offer a...}},
    author = {Wadler, Philip},
    booktitle = {IFIP TC 2 Working Conference on Programming Concepts and Methods},
    citeulike-article-id = {70953},
    citeulike-linkout-0 = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.55.5439},
    comment = {paper\_depo/10.1.1.31.5002.pdf },
    editor = {Broy, M. and Jones, C.},
    location = {Sea of Galilee, Israel},
    pages = {347--359},
    posted-at = {2012-09-12 21:52:45},
    priority = {2},
    publisher = {North Holland},
    title = {{Linear Types Can Change the World!}},
    url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.55.5439},
    year = {1990}
}

@inproceedings{Leuschel2001How,
    abstract = {{We study the possibility of doing LTL model checking on CSP specifications in the context of refinement. We present evidence that the refinement-based approach to verification does not seem to be very well suited for verifying certain temporal properties. To remedy this problem, we show how to (and how not to) perform LTL model checking of CSP processes using refinement checking in general and the FDR tool in particular. We show how one can handle (potentially) deadlocking systems, discuss the validity of our approach for infinite state systems, and shed light on the relationship between "classical" model checking and refinement checking.}},
    address = {London, UK, UK},
    author = {Leuschel, Michael and Massart, Thierry and Currie, Andrew},
    booktitle = {Proceedings of the International Symposium of Formal Methods Europe on Formal Methods for Increasing Software Productivity},
    citeulike-article-id = {2841549},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=730012},
    comment = {paper\_depo/Leuschel2001How.pdf },
    isbn = {3-540-41791-5},
    pages = {99--118},
    posted-at = {2012-09-12 21:49:29},
    priority = {2},
    publisher = {Springer-Verlag},
    series = {FME '01},
    title = {{How to Make FDR Spin LTL Model Checking of CSP by Refinement}},
    url = {http://portal.acm.org/citation.cfm?id=730012},
    year = {2001}
}

@article{Appel1998SSA,
    abstract = {{An abstract is not available.}},
    address = {New York, NY, USA},
    author = {Appel, Andrew W.},
    citeulike-article-id = {4639},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=278285},
    citeulike-linkout-1 = {http://dx.doi.org/10.1145/278283.278285},
    comment = {paper\_depo/10.1.1.34.3282.pdf},
    doi = {10.1145/278283.278285},
    issn = {0362-1340},
    journal = {SIGPLAN Not.},
    month = apr,
    number = {4},
    pages = {17--20},
    posted-at = {2012-09-10 20:31:27},
    priority = {2},
    publisher = {ACM},
    title = {{SSA is Functional Programming}},
    url = {http://dx.doi.org/10.1145/278283.278285},
    volume = {33},
    year = {1998}
}

@inproceedings{LTSMP,
    abstract = {{ In this day and age of multicore architectures, programming language support is in urgent need for constructing programs that can take great advantage of machines with multiple cores. We present in this paper an approach to safe multicore programming in ATS, a recently developed functional programming language that supports both linear and dependent types. In particular, we fo@inproceedings{LTSMP, author = "Rui Shi and Hongwei Xi", title = {{A Linear Type System for Multicore Programming}} booktitle = {Proceedings of Simposio Brasileiro de Linguagens de Programacao}, year = "2009", month = "August", address = "Gramado, Brazil", abstract = {{ In this day and age of multicore architectures, programming language support is in urgent need for constructing programs that can take great advantage of machines with multiple cores. We present in this paper an approach to safe multicore programming in ATS, a recently developed functional programming language that supports both linear and dependent types. In particular, we formalize a type system capable of guaranteeing safe manipulation of resources on multicore machines and establish its soundness. We also provide concrete examples as well as experimental results in support of the practicality of the presented approach to multicore programming. }} } rmalize a type system capable of guaranteeing safe manipulation of resources on multicore machines and establish its soundness. We also provide concrete examples as well as experimental results in support of the practicality of the presented approach to multicore programming. }},
    address = {Gramado, Brazil},
    author = {Shi, Rui and Xi, Hongwei},
    booktitle = {Proceedings of Simposio Brasileiro de Linguagens de Programacao},
    citeulike-article-id = {11188845},
    keywords = {*file-import-12-09-05},
    month = aug,
    posted-at = {2012-09-05 01:23:06},
    priority = {2},
    title = {{A Linear Type System for Multicore Programming}},
    year = {2009}
}

@article{Wing1988Study,
    abstract = {{The author studies twelve specifications for a seemingly simple database problem and demonstrates many approaches for classifying informally stated problem requirements. She compares the specifications according to how they address problems of the library example to illustrate the imprecision of natural-language specifications and how twelve different approaches to the same set of informal requirements reveal many of the same problems. The comparison suggests which issues should be addressed in refining an informal set of requirements and shows how these issues are resolved in different specification approaches.}},
    address = {Los Alamitos, CA, USA},
    author = {Wing, Jeannette M.},
    citeulike-article-id = {11159293},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=624570.624745},
    citeulike-linkout-1 = {http://dx.doi.org/10.1109/52.17803},
    comment = {paper\_depo/Wing88.pdf
paper\_depo/A study of twelve specifications of the library problem.pdf (Technical Report of CMU)},
    doi = {10.1109/52.17803},
    issn = {0740-7459},
    journal = {IEEE Softw.},
    month = jul,
    number = {4},
    pages = {66--76},
    posted-at = {2012-08-31 02:27:06},
    priority = {2},
    publisher = {IEEE Computer Society Press},
    title = {{A Study of 12 Specifications of the Library Problem}},
    url = {http://dx.doi.org/10.1109/52.17803},
    volume = {5},
    year = {1988}
}

@article{Kemmerer1985Testing,
    abstract = {{Formal specification and verification techniques are now apused to increase the reliability of software systems. However, these proaches sometimes result in specifying systems that cannot be realized or that are not usable. This paper demonstrates why it is necessary to test specifications early in the software life cycle to guarantee a system that meets its critical requirements and that also provides the desired functionality. Definitions to provide the framework for classifying the validity of a functional requirement with respect to a formal specification tion are also introduced. Finally, the design of two tools for testing formal specifications is discussed.}},
    address = {Piscataway, NJ, USA},
    author = {Kemmerer, R. A.},
    citeulike-article-id = {11159292},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=1437068},
    citeulike-linkout-1 = {http://dx.doi.org/10.1109/TSE.1985.231535},
    comment = {paper\_depo/testspec.pdf},
    doi = {10.1109/TSE.1985.231535},
    issn = {0098-5589},
    journal = {IEEE Trans. Softw. Eng.},
    month = jan,
    number = {1},
    pages = {32--43},
    posted-at = {2012-08-31 02:24:50},
    priority = {2},
    publisher = {IEEE Press},
    title = {{Testing Formal Specifications to Detect Design Errors}},
    url = {http://dx.doi.org/10.1109/TSE.1985.231535},
    volume = {11},
    year = {1985}
}

@inproceedings{Shi2000Java2CSP,
    author = {Shi, Hui},
    booktitle = {FM-TOOLS},
    citeulike-article-id = {11150180},
    comment = {paper\_depo/10.1.1.88.5346.pdf},
    pages = {111--115},
    posted-at = {2012-08-28 21:39:44},
    priority = {2},
    title = {{Java2CSP: A System for Verifying Concurrent Java Programs}},
    year = {2000}
}

@article{Yahav2001Verifying,
    abstract = {{We provide a parametric framework for verifying safety properties of concurrent Java programs. The framework combines thread-scheduling information with information about the shape of the heap. This leads to error-detection algorithms that are more precise than existing techniques. The framework also provides the most precise shape-analysis algorithm for concurrent programs. In contrast to existing verification techniques, we do not put a bound on the number of allocated objects. The framework even produces interesting results when analyzing Java programs with an unbounded number of threads. The framework is applied to successfully verify the following properties of a concurrent program: \&bull;Concurrent manipulation of linked-list based ADT preserves the ADT datatype invariant [19]. \&bull;The program does not perform inconsistent updates due to interference. \&bull;The program does not reach a deadlock. \&bull;The program does not produce run-time errors due to illegal thread interactions. We also find bugs in erroneous versions of such implementations. A prototype of our framework has been implemented.}},
    address = {New York, NY, USA},
    author = {Yahav, Eran},
    booktitle = {Proceedings of the 28th ACM SIGPLAN-SIGACT symposium on Principles of programming languages},
    citeulike-article-id = {9403559},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=360206},
    citeulike-linkout-1 = {http://dx.doi.org/10.1145/360204.360206},
    comment = {paper\_depo/p27-yahav.pdf},
    doi = {10.1145/360204.360206},
    isbn = {1-58113-336-7},
    issn = {0362-1340},
    journal = {SIGPLAN Not.},
    location = {London, United Kingdom},
    month = jan,
    number = {3},
    pages = {27--40},
    posted-at = {2012-08-28 21:26:57},
    priority = {2},
    publisher = {ACM},
    series = {POPL '01},
    title = {{Verifying safety properties of concurrent Java programs using 3-valued logic}},
    url = {http://dx.doi.org/10.1145/360204.360206},
    volume = {36},
    year = {2001}
}

@article{Bartels2011Verification,
    abstract = {{Process algebras like Timed CSP offer a convenient level of abstraction for the specification and verification of distributed embedded real-time systems. Complex systems can be specified in terms of interacting modules whose interaction can be analyzed using the mechanisms of the process algebra. In this paper, we present a development approach that supports the construction of distributed real-time systems by exploiting Timed CSP's concept of modularity. Individual system components are refined to their low-level implementations and shown to be a formally correct implementation of their respective Timed CSP specifications. Their interaction can then be analyzed by composing the individual process specifications. The key idea underlying the presented approach is a formal relation between timed process algebraic specifications and implementations given in a general purpose programming language.}},
    address = {Los Alamitos, CA, USA},
    author = {Bartels, Bjorn and Glesner, Sabine},
    citeulike-article-id = {11066593},
    citeulike-linkout-0 = {http://doi.ieeecomputersociety.org/10.1109/APSEC.2011.52},
    citeulike-linkout-1 = {http://dx.doi.org/10.1109/APSEC.2011.52},
    comment = {paper\_depo/06130687.pdf},
    doi = {10.1109/APSEC.2011.52},
    issn = {1530-1362},
    journal = {Asia-Pacific Software Engineering Conference},
    pages = {195--202},
    posted-at = {2012-08-15 02:56:27},
    priority = {2},
    publisher = {IEEE Computer Society},
    title = {{Verification of Distributed Embedded Real-Time Systems and their Low-Level Implementations Using Timed CSP}},
    url = {http://dx.doi.org/10.1109/APSEC.2011.52},
    volume = {0},
    year = {2011}
}

@inproceedings{Sputh2006Portable,
    abstract = {{Modern lifestyle depends on embedded systems. They are everywhere: sometimes they are hidden and at other times they are handled as a fashion accessory. In order to serve us better they have to do more and more tasks at the same time. This calls for sophisticated mechanisms to handle concurrency. In this paper we present CSP (Communicating Sequential Processes) as a method which helps to solve a number of problems of embedded concurrent systems. To be specific, we describe implementations of the commstime benchmark in multithreaded, multiprocessor and architecture fusion systems. An architecture fusion system combines machine and hardware-logic architectures. Our results are twofold. First, architecture fusion systems outperform all the other systems we tested. Second, we implemented all the systems without a change in the design philosophy. The second point is the more important result, because it shows the power of CSP based design methods.}},
    author = {Sputh, Bernhard and Faust, Oliver and Allen, Alastair R.},
    booktitle = {{C}ommunicating {P}rocess {A}rchitectures 2006},
    citeulike-article-id = {11066592},
    comment = {paper\_depo/CPA-123-Sputh.pdf},
    editor = {Barnes, Frederick R. M. and Kerridge, Jon M. and Welch, Peter H.},
    isbn = {1-58603-671-8},
    month = sep,
    posted-at = {2012-08-15 02:53:01},
    priority = {2},
    title = {{P}ortable {CSP} {B}ased {D}esign for {E}mbedded {M}ulti-{C}ore {S}ystems},
    year = {2006}
}

@inproceedings{Carter2005Rapid,
    abstract = {{Our software synthesis tool, CSP++, generates C++ source code from verifiable CSPm specifications, and includes a framework for runtime execution. Our technique of selective formalism allows the synthesized formal control backbone code to be linked with non-formal user-coded C++ functions that carry out I/O and data processing. This tool already facilitates rapid prototyping of formally-specified software by bypassing the customary manual translation from a formal notation. In this work, we extend the rapid prototyping capability to SOPC (system on programmable chip) by targeting the CSP++ execution framework to an FPGA processor core. This is demonstrated with a new point-of-sale case study.}},
    author = {Carter, J. and Xu, M. and Gardner, W. B.},
    booktitle = {The 16th IEEE International Worksh16th IEEE International Workshop on Rapid System Prototyping (RSP 2005)},
    citeulike-article-id = {11066575},
    citeulike-linkout-0 = {http://dx.doi.org/10.1109/RSP.2005.43},
    citeulike-linkout-1 = {http://ieeexplore.ieee.org/xpls/abs\_all.jsp?arnumber=1509439},
    comment = {paper\_depo/RSP05-RP.pdf},
    doi = {10.1109/RSP.2005.43},
    institution = {Dept. of Comput. \& Inf. Sci., Guelph Univ., Ont., Canada},
    isbn = {0-7695-2361-7},
    issn = {1074-6005},
    month = jun,
    pages = {99--104},
    posted-at = {2012-08-15 02:41:05},
    priority = {2},
    publisher = {IEEE},
    title = {{Rapid prototyping of embedded software using selective formalism}},
    url = {http://dx.doi.org/10.1109/RSP.2005.43},
    year = {2005}
}

@inproceedings{Bartels2011CSPbased,
    abstract = {{The process algebra CSP is tailored for the specification and verification of reactive systems. Such systems react upon external stimuli by adjusting their internal behavior, e.g., to recover from errors. Adaptive systems can be regarded as a subclass of reactive systems in the sense that such systems react by adapting to changes propagated by some stimulus. In this paper, we use CSP for the specification, verification and implementation of adaptive systems. This enables us to use standard CSP tools such as FDR, ProB or the CSP-Prover for the verification of such systems. Furthermore, we present an approach for the implementation of systems specified in CSP.}},
    address = {New York, NY, USA},
    author = {Bartels, Bj\"{o}rn and Kleine, Moritz},
    booktitle = {Proceedings of the 6th International Symposium on Software Engineering for Adaptive and Self-Managing Systems},
    citeulike-article-id = {11066537},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=1988030},
    citeulike-linkout-1 = {http://dx.doi.org/10.1145/1988008.1988030},
    comment = {paper\_depo/p158-bartels.pdf
SEAMS ppt: paper\_depo/SEAMS2011\_6\_Bartels.pdf},
    doi = {10.1145/1988008.1988030},
    isbn = {978-1-4503-0575-4},
    location = {Waikiki, Honolulu, HI, USA},
    pages = {158--167},
    posted-at = {2012-08-15 02:34:00},
    priority = {4},
    publisher = {ACM},
    series = {SEAMS '11},
    title = {{A CSP-based framework for the specification, verification, and implementation of adaptive systems}},
    url = {http://dx.doi.org/10.1145/1988008.1988030},
    year = {2011}
}

@inproceedings{Welch2000Formal,
    abstract = {{Abstract. Java threads are synchronised through primitives based upon monitor concepts developed in the early 1970s. The semantics of Java\^{a}s primitives have only been presented in natural language \^{a} this paper remedies this with a simple and formal CSP model. In view of the difficulties encountered in reasoning about any non-trivial interactions between Java threads, being able to perform that reasoning in a formal context (where careless errors can be highlighted by mechanical checks) should be a considerable confidence boost. Further, automated model-checking tools can be used to root out dangerous states (such as deadlock and livelock), find overlooked race hazards and prove equivalence between algorithms (e.g. between optimised and unoptimised versions). A case study using the CSP model to prove the correctness of the JCSP and CTJ channel implementations (which are built using standard Java monitor synchronisation) is presented. In addition, the JCSP mechanism for ALTing (i.e. waiting for and, then, choosing between multiple events) is verified. Given the history of erroneous implementations of this key primitive, this is a considerable relief.}},
    author = {Welch, P. H. and Eds, A. W. P. Bakkers and Welch, Peter H. and Martin, Jeremy M. R.},
    booktitle = {Proceedings of Communicating Process Architectures \^{a} 2000},
    citeulike-article-id = {10974266},
    citeulike-linkout-0 = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.170.9099},
    comment = {paper\_depo/10.1.1.170.9099.pdf},
    posted-at = {2012-07-30 22:52:49},
    priority = {2},
    title = {{Formal Analysis of Concurrent Java Systems}},
    url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.170.9099},
    year = {2000}
}

@inproceedings{Welch2000CSP,
    abstract = {{Java threads are synchronized through primitives based upon monitor concepts developed in the early 1970s. The semantics of Java's primitives have only been presented in natural language -- this paper remedies this with a simple and formal CSP model. In view of the difficulties encountered in reasoning about any non-trivial interactions between Java threads, being able to perform that reasoning in a formal context (where careless errors can be highlighted by mechanical checks) should be a considerable confidence boost. Further, automated model-checking tools can be used to root out dangerous states (such as deadlock and livelock), find overlooked race hazards and prove equivalence between algorithms (e.g. between optimized and unoptimized versions). A case study using the CSP model to prove the correctness of the JCSP channel implementation (which is built in terms of standard Java monitor synchronizations) is presented.}},
    address = {Washington, DC, USA},
    author = {Welch, Peter H. and Martin, Jeremy M. R.},
    booktitle = {Proceedings of the International Symposium on Software Engineering for Parallel and Distributed Systems},
    citeulike-article-id = {10974264},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=826323},
    comment = {paper\_depo/06340114.pdf},
    isbn = {0-7695-0634-8},
    posted-at = {2012-07-30 22:47:30},
    priority = {2},
    publisher = {IEEE Computer Society},
    series = {PDSE '00},
    title = {{A CSP Model for Java Multithreading}},
    url = {http://portal.acm.org/citation.cfm?id=826323},
    year = {2000}
}

@article{McewanIntegrating,
    abstract = {{Abstract. This paper presents the extended and re-integrated JCSP library of CSP packages for Java. It integrates the differing advances made by Quickstone\^{a}s JCSP Network Edition and the \^{a}core \^{a} library maintained at Kent. A more secure API for connecting networks and manipulating channels is provided, requiring significant}},
    author = {Mcewan, Alistair A. and Schneider, Steve and Ifill, Wilson and Welch, Peter and Peter Welch, A. and Neil Brown, A. and James Moores, B. and Kevin Chalmers, C. and Bernhard Sputh, D.},
    citeulike-article-id = {10918297},
    citeulike-linkout-0 = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.137.6474},
    comment = {paper\_depo/jcsp-paper-2007.pdf},
    posted-at = {2012-07-23 21:47:19},
    priority = {2},
    title = {{Integrating and Extending JCSP}},
    url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.137.6474}
}

@article{CreeseFormal,
    abstract = {{We show how data independence results can be used to generalise an inductive proof from binary to arbitrary branching tree networks. The example used is modelled on the RSVP Resource Reservation Protocol. Of particular interest is the need for a separate lower-level induction which is itself closely tied to data independence. The inductions combine the use of the process algebra CSP to model systems and their specifications, and the FDR tool to discharge the various proof obligations.}},
    author = {Creese, S. J. and Roscoe, A. W.},
    citeulike-article-id = {10912879},
    citeulike-linkout-0 = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.161.9337},
    comment = {paper\_depo/10.1.1.161.9337.pdf},
    posted-at = {2012-07-23 02:08:12},
    priority = {2},
    title = {{Formal Verification of Arbitrary Network Topologies}},
    url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.161.9337}
}

@phdthesis{Gardner2000CSP,
    abstract = {{One of the useful formalisms for designing concurrent systems is the process algebra
called CSP, or Communicating Sequential Processes. CSP statements can be used to
model a system's control and data flow in an intuitive way, constituting a kind of hierarchical
behavioral specification. Furthermore, when coupled with simulation and modelchecking
tools, these statements can be executed and debugged until the desired behavior
has been accurately captured. Certain properties (such as absence of deadlocks) can be
proved, to help verify the correctness of the design.
To make the verified specifications executable in a practical sense, refinement to a
programming language is required. In this work, an new object-oriented application
framework is described which realizes the basic elements of CSP—processes, synchronizing
events, and communication channels—in natural terms as C++ objects. In addition,
a new software tool is provided to customize the framework by translating CSP statements
into invocations of the framework elements. CSP specifications, thus reexpressed
in C++ and compiled, form the control portion of a system, able to be linked with other
software written in C++ that completes the functionality.}},
    author = {Gardner, William B.},
    citeulike-article-id = {10874456},
    comment = {paper\_depo/gardner.pdf},
    institution = {Department of Computer Science, University of Victoria, Canada},
    posted-at = {2012-07-10 23:41:23},
    priority = {5},
    title = {{CSP++: An Object-Oriented Application Framework for Software Synthesis from CSP Specifications}},
    year = {2000}
}

@inproceedings{Welch1989Graceful,
    abstract = {{Correct \^{a} let alone graceful \^{a} termination of parallel systems is sometimes thought to be a difficult problem. This is particularly imagined to be so under the pure message-passing MIMD discipline of occam and transputer networks, where global operations (like setting a shared flag or abortions) are not allowed and where time-outs cannot be set for every communication. This paper describes some common, but erroneous, occam approaches to this problem and contrasts them with what can be done in Ada [0, 1, 2]. These methods are all rejected on the grounds of insecurity and performance overheads. A simple, legal, secure and efficient occam method is then presented. This method also solves a much more important problem \^{a} the general (or partial) resetting of a parallel system (or sub-system). The resetting mechanism is quite independent of the parallel application algorithm, which can therefore be developed without worrying about such matters. This separation of concerns is good software engineering and is fully supported by the occam philosophy. Finally, an application of this resetting mechanism is described that permits the dynamic reconstruction of occam network topologies.}},
    author = {Welch, P. H.},
    booktitle = {In Applying Transputer-Based Parallel Machines, Proceedings of OUG 10},
    citeulike-article-id = {10874448},
    citeulike-linkout-0 = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.159.5192},
    comment = {paper\_depo/10.1.1.159.5192.pdf},
    pages = {310--317},
    posted-at = {2012-07-10 23:23:56},
    priority = {2},
    title = {{Graceful Termination \^{a} Graceful Resetting}},
    url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.159.5192},
    year = {1989}
}

@inproceedings{Sputh2005JCSPPoison,
    author = {Sputh, Bernhard H. C. and Allen, Alastair R.},
    booktitle = {CPA},
    citeulike-article-id = {10874446},
    citeulike-linkout-0 = {http://dblp.uni-trier.de/db/conf/wotug/cpa2005.html\#SputhA05},
    comment = {paper\_depo/jcsp-p.pdf},
    editor = {Broenink, Jan F. and Roebbers, Herman W. and Sunter, Johan P. E. and Welch, Peter H. and Wood, David C.},
    keywords = {dblp, *file-import-12-07-10},
    pages = {71--107},
    posted-at = {2012-07-10 23:18:06},
    priority = {2},
    publisher = {IOS Press},
    series = {Concurrent Systems Engineering Series},
    title = {{JCSP-Poison: Safe Termination of CSP Process Networks.}},
    url = {http://dblp.uni-trier.de/db/conf/wotug/cpa2005.html\#SputhA05},
    volume = {63},
    year = {2005}
}

@inproceedings{Bartels2010Formal,
    abstract = {{Process-algebraic formalisms offer convenient mechanisms for specifying and analyzing concurrent system behavior on an abstract level, but the high level of abstraction comes at the cost of introducing a semantic gap between the actual implementation and its specification. To bridge this gap, we semi-automatically synthesize a process-specific system model from its implementation-level description. In this paper, we show how the correctness of the synthesis procedure can be shown for a given instance by establishing a bisimulation relation between the process-specific model and its low-level system model. This enables us to reason about a system on an abstract level that faithfully captures the semantics of the low-level implementation.}},
    address = {Washington, DC, USA},
    author = {Bartels, Bj\"{o}rn and Glesner, Sabine},
    booktitle = {Proceedings of the 2010 10th International Conference on Quality Software},
    citeulike-article-id = {10828314},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=1849239},
    citeulike-linkout-1 = {http://dx.doi.org/10.1109/QSIC.2010.67},
    comment = {paper\_depo/4131a200.pdf},
    doi = {10.1109/QSIC.2010.67},
    isbn = {978-0-7695-4131-0},
    pages = {200--207},
    posted-at = {2012-06-26 00:52:21},
    priority = {2},
    publisher = {IEEE Computer Society},
    series = {QSIC '10},
    title = {{Formal Modeling and Verification of Low-Level Software Programs}},
    url = {http://dx.doi.org/10.1109/QSIC.2010.67},
    year = {2010}
}

@techreport{Gardner2009CSP,
    abstract = {{The CSP++ object-oriented application framework, which implements CSP execution semantics based on Pth multithreading, is released as open source in C++. The new  ” micro” version, more suitable for embedded platforms, can be built using GNU autotools, and comes with a suite of regression tests. An Eclipse plug-in is available for application developers. It features a syntax highlighter for CSPm specifications, and is integrated with the FDR2, ProBE, and Checker tools from Formal Systems. The design flow from CSPm input, through formal verification, translation with cspt, integration of user-coded functions, execution with the CSP++ framework, and trace refinement checking will be demonstrated.}},
    author = {Gardner, W. B. and Moore-Oliva, J. and Carter, J. and Gumtie, A. and Solovyov, Y.},
    citeulike-article-id = {10817312},
    comment = {paper\_depo/TR\_0901.pdf},
    day = {1},
    institution = {University of Guelph},
    month = jan,
    posted-at = {2012-06-22 21:07:17},
    priority = {2},
    school = {Department of Computing and Information Science},
    title = {{CSP++: An Open Source Tool for Building Concurrent Applications from CSP Specifications}},
    year = {2009}
}

@inproceedings{Gardner2008Getting,
    author = {Gardner, William B.},
    booktitle = {Proceedings of The Sixth NASA Langley Formal Methods Workshop (LFM 2008)},
    citeulike-article-id = {10817298},
    comment = {paper\_depo/NASA-cp-2008-215309.pdf},
    day = {30},
    institution = {University of Guelph, Ontario, Canada},
    month = apr,
    pages = {23--25},
    posted-at = {2012-06-22 21:00:14},
    priority = {2},
    title = {{Getting Somewhat Formal with CSP and C++}},
    year = {2008}
}

@article{Brown2007CCSP2,
    abstract = {{The advent of mass-market multicore processors provides exciting new opportunities for parallelism on the desktop. The original C++CSP – a library providing concurrency in C++ – used only user-threads, which would have prevented it taking advantage of this parallelism. This paper details the development of C++CSP2, which has been built around a many-to-many threading model that mixes user-threads and kernel-threads, providing maximum flexibility in taking advantage of multicore and multi-processor machines. New and existing algorithms are described for dealing with the run-queue and implementing channels, barriers and mutexes. The latter two are benchmarked to motivate the choice of algorithm. Most of these algorithms are based on the use of atomic instructions, to gain maximal speed and efficiency. Other issues related to the new design and related to implementing concurrency in a language like C++ that has no direct support for it, are also described. The C++CSP2 library will be publicly released under the LGPL before CPA 2007.}},
    author = {Brown, Neil},
    citeulike-article-id = {10794191},
    citeulike-linkout-0 = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.159.6717},
    comment = {paper\_depo/10.1.1.159.6717.pdf},
    keywords = {formal\_methods},
    posted-at = {2012-06-16 03:22:35},
    priority = {2},
    title = {{C++CSP2: A Many-to-Many Threading Model for Multicore Architectures}},
    url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.159.6717},
    year = {2007}
}

@manual{2010FailuresDivergence,
    citeulike-article-id = {10780189},
    comment = {book/fdr2manual.pdf},
    day = {19},
    edition = {9},
    institution = {Oxford University Computing Laboratory},
    keywords = {csp},
    month = oct,
    organization = {Formal Systems (Europe) Ltd},
    posted-at = {2012-06-11 17:52:42},
    priority = {2},
    title = {{Failures-Divergence Refinement -- FDR2 User Manual}},
    year = {2010}
}

@inproceedings{Anshus2007PyCSP,
    author = {Anshus, Otto J. and Bj{\o}rndalen, John M. and Vinter, Brian},
    booktitle = {Communicating Process Architectures 2007},
    citeulike-article-id = {8816305},
    comment = {paper\_depo/10.1.1.105.3040.pdf},
    editor = {McEwan, Alistair A. and Ifill, Wilson and Welch, Peter H.},
    keywords = {formal\_methods},
    month = jul,
    pages = {229--248},
    posted-at = {2012-06-10 21:40:45},
    priority = {2},
    title = {{PyCSP - Communicating Sequential Processes for Python}},
    year = {2007}
}

@inproceedings{Brown2008Communicating,
    abstract = {{Writing concurrent programs in languages that lack explicit support for concurrency can often be awkward and difficult. Haskell's monads provide a way to explicitly specify sequence and effects in a functional language, and monadic combinators allow composition of monadic actions, for example via parallelism and choice two core aspects of Communicating Sequential Processes (CSP). We show how the use of these combinators, and being able to express processes as first-class types (monadic actions) allow for easy and elegant programming of process-oriented concurrency in a new CSP library for Haskell: Communicating Haskell Processes.}},
    author = {Brown, Neil C. C.},
    booktitle = {Communicating Process Architectures 2008},
    citeulike-article-id = {10777144},
    comment = {paper\_depo/Brown2008Communicating.pdf},
    keywords = {formal\_methods},
    month = sep,
    pages = {67--84},
    posted-at = {2012-06-10 19:13:09},
    priority = {2},
    title = {{Communicating Haskell Processes: Composable Explicit Concurrency using Monads.}},
    year = {2008}
}

@incollection{Lawrence2005Practical,
    abstract = {{Most published material on CSP and the FDR tool is theoretical and mathematically rigorous, which can be daunting to the less mathematical software engineer. It is also often difficult to relate the elegant but abstract examples in the literature to the problems of the software engineer who must eventually produce an executable program expressed in a procedural programming language This paper outlines a number of techniques which may be used to model procedural designs in CSP and to structure the refinements so as to render them tractable to verification by the FDR model-checking tool. A simple example, taken from a recent IBM Software Services engagement, is used to illustrate some of the ideas presented in the paper.}},
    address = {Berlin, Heidelberg},
    author = {Lawrence, Jonathan},
    chapter = {9},
    citeulike-article-id = {1574472},
    citeulike-linkout-0 = {http://dx.doi.org/10.1007/11423348\_9},
    citeulike-linkout-1 = {http://www.springerlink.com/content/xf23c6nvh1g8dm5g},
    comment = {paper\_depo/Lawrence2005Practical.pdf},
    doi = {10.1007/11423348\_9},
    editor = {Abdallah, Ali E. and Jones, Cliff B. and Sanders, Jeff W.},
    isbn = {978-3-540-25813-1},
    journal = {Communicating Sequential Processes},
    keywords = {formal\_methods},
    pages = {717--721},
    posted-at = {2012-06-05 23:47:25},
    priority = {2},
    publisher = {Springer Berlin / Heidelberg},
    series = {Lecture Notes in Computer Science},
    title = {{Practical Application of CSP and FDR to Software Design Communicating Sequential Processes. The First 25 Years}},
    url = {http://dx.doi.org/10.1007/11423348\_9},
    volume = {3525},
    year = {2005}
}

@inproceedings{Roscoe1988Unbounded,
    abstract = {{ABSTRACT. We extend the failures/divergences model for CSP to include a component of infinite traces. This allows us to give a denotational semantics for a version of CSP including general nondeterministic choice and infinite hiding. Unfortunately the model is an incomplete partial order, so it is by no means obvious that the necessary fixed points exist. We have two proofs of this result, one via a congruence theorem with operational semantics and one via a careful analysis of operators ' behaviour on a subset of the model. As is well known to the theoretical community, it is generally far easier to model finite nondetermJnism (where a process can only choose between finitely many options at any one time) than unbounded nondeterminism (where no such restriction applies). The difficulties encountered with unbounded nondeterminism have hitherto forced}},
    author = {Roscoe, A. W. and Barrett, Geoff},
    booktitle = {Journal of Logic and Computation},
    citeulike-article-id = {10745258},
    citeulike-linkout-0 = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.109.208},
    comment = {paper\_depo/10.1.1.109.208.pdf},
    keywords = {formal\_methods},
    pages = {131--172},
    posted-at = {2012-06-05 18:16:53},
    priority = {2},
    title = {{Unbounded Nondeterminism in CSP}},
    url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.109.208},
    year = {1988}
}

@book{Roscoe1997Theory,
    abstract = {{Since the introduction of Hoare's Communicating Sequential Processes notation, powerful new tools have transformed CSP into a practical way of describing industrial-sized problems. This book gives you the fundamental grasp of CSP concepts you'll need to take advantage of those tools.Part I provides a detailed foundation for working with CSP, using as little mathematics as possible. It introduces the ideas behind operational, denotational and algebraic models of CSP. Parts II and III go into greater detail about theory and practice. Topics include: parallel operators, hiding and renaming, piping and enslavement, buffers and communication, termination and sequencing, and semantic theory. Three detailed practical case studies are also presented. For anyone interested in modeling sequential processes.}},
    address = {Upper Saddle River, NJ, USA},
    author = {Roscoe, A. W.},
    citeulike-article-id = {1010001},
    citeulike-linkout-0 = {http://www.comlab.ox.ac.uk/people/bill.roscoe/publications/68b.pdf},
    citeulike-linkout-1 = {http://portal.acm.org/citation.cfm?id=550448},
    comment = {book/TheTheorandPracticeofConcurrency.pdf},
    howpublished = {Paperback},
    isbn = {0136744095},
    keywords = {csp, formal\_methods},
    posted-at = {2012-06-01 23:18:06},
    priority = {2},
    publisher = {Prentice Hall PTR},
    title = {{The Theory and Practice of Concurrency}},
    url = {http://www.comlab.ox.ac.uk/people/bill.roscoe/publications/68b.pdf},
    year = {1997}
}

@phdthesis{Scattergood1998Semantics,
    author = {Scattergood, Bryan},
    citeulike-article-id = {4948045},
    comment = {paper\_depo/10.1.1.66.1542.pdf},
    keywords = {formal\_methods},
    posted-at = {2012-06-01 03:28:47},
    priority = {2},
    school = {University of Oxford},
    title = {{The Semantics and Implementation of Machine-Readable CSP}},
    year = {1998}
}

@article{Techniques2001Temporal,
    abstract = {{We study the possibility of doing LTL model checking on  CSP speci  cations in the context of re  nement. We present a technique to  perform LTL model checking of CSP processes using re  nement checking  in general and the FDR tool in particular. We present a tool which  automates the translation process from LTL model checking to CSP  re  nement. Also, if time permits, we will present another tool which uses  latest generation Prolog technology to symbolically animate, compile,  and model check CSP speci  cations.}},
    author = {Techniques, Tools A. and Leuschel, Michael and Wolton, Ivan and Massart, Thierry and Adhianto, Laksono},
    citeulike-article-id = {10723465},
    citeulike-linkout-0 = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.12.9645},
    keywords = {formal\_methods},
    posted-at = {2012-06-01 03:17:03},
    priority = {2},
    title = {{Temporal Logic Model Checking of CSP:}},
    url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.12.9645},
    year = {2001}
}

@manual{Scattergood2011CSPM,
    author = {Scattergood, Bryan and Armstrong, Philip},
    citeulike-article-id = {10723434},
    comment = {paper\_depo/cspm.pdf},
    day = {24},
    keywords = {formal\_methods},
    month = jan,
    posted-at = {2012-06-01 02:58:51},
    priority = {2},
    title = {{CSPM: A Reference Manual}},
    year = {2011}
}

@inproceedings{Gardner2003Bridging,
    abstract = {{CSP (Communicating Sequential Processes) is a usefulalgebraic notation for creating a hierarchical behaviouralspecification for concurrent systems, due to its formalinterprocess synchronization and communication semantics.CSP specifications are amenable to simulation andformal verification by model-checking tools. To overcomethe drawback that CSP is neither a full-featured nor popularprogramming language, an approach called "selectiveformalism" allows the use of CSP to be limited to specifyingthe control portion of a system, while the rest of itsfunctionality is supplied in the form of C++ modules.These are activated through association with abstractevents in the CSP specification. The target system is constructedusing a framework called CSP++, which automaticallytranslates CSP specifications into C++, therebymaking CSP directly executable. Thus a bridge is built thatallows a formal method to be combined with a popularprogramming language. It is believed that this methodologycan be extended to hardware/software codesign.}},
    address = {Washington, DC, USA},
    author = {Gardner, W. B.},
    booktitle = {Proceedings of the First ACM and IEEE International Conference on Formal Methods and Models for Co-Design},
    citeulike-article-id = {10723426},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=823837},
    comment = {paper\_depo/MEMOCODE03.pdf},
    isbn = {0-7695-1923-7},
    keywords = {formal\_methods},
    posted-at = {2012-06-01 02:55:13},
    priority = {2},
    publisher = {IEEE Computer Society},
    series = {MEMOCODE '03},
    title = {{Bridging CSP and C++ with Selective Formalism and Executable Specifications}},
    url = {http://portal.acm.org/citation.cfm?id=823837},
    year = {2003}
}

@inbook{Girard1989Proofs,
    abstract = {{This book is derived from notes prepared by J-Y.Girard for a course at the University of Paris VII. It deals with the mathematical background of the application to computer science of aspects of logic. It sheds light on traditional logic material and its prospective application to computer science.}},
    author = {Girard, Jean-Yves and Lafon, Yves and Taylor, Paul},
    booktitle = {Proofs and Types},
    chapter = {2, 3, 4, 6, 11},
    citeulike-article-id = {10721071},
    comment = {book/prot.pdf},
    day = {28},
    isbn = {0521371813},
    keywords = {type\_theory},
    month = apr,
    posted-at = {2012-05-31 01:16:19},
    priority = {2},
    publisher = {Cambridge University Press},
    series = {Cambridge Tracts in Theoretical Computer Science},
    title = {{Proofs and Types}},
    year = {1989}
}

@article{Xi2007Dependent,
    abstract = {{We present an approach to enriching the type system of ML with a restricted form of dependent types, where type index terms are required to be drawn from a given type index language L that is completely separate from run-time programs, leading to the DML(L) language schema. This enrichment allows for specification and inference of significantly more precise type information, facilitating program error detection and compiler optimization. The primary contribution of the paper lies in our language design, which can effectively support the use of dependent types in practical programming. In particular, this design makes it both natural and straightforward to accommodate dependent types in the presence of effects such as references and exceptions.}},
    author = {Xi, Hongwei},
    citeulike-article-id = {10721050},
    comment = {paper\_depo/JFPdml.pdf},
    journal = {Journal of Functional Programming},
    keywords = {programming\_language},
    number = {2},
    pages = {215--286},
    posted-at = {2012-05-31 01:01:35},
    priority = {2},
    title = {{Dependent ML: an approach to practical programming with dependent types}},
    volume = {17},
    year = {2007}
}

@inproceedings{Holzmann2004Modeldriven,
    abstract = {{gerard.j.holzmann4jpl.nasa.gov}},
    author = {Holzmann, Gerard J. and Joshi, Rajeev},
    booktitle = {In Proc. 2001 ACM SIGPLAN–SIGSOFT Workshop on Program Analysis for Software Tools and Engineering (PASTE'01},
    citeulike-article-id = {10720993},
    citeulike-linkout-0 = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.112.1504},
    comment = {paper\_depo/10.1.1.112.1504.pdf},
    keywords = {formal\_methods},
    pages = {80--89},
    posted-at = {2012-05-31 00:37:45},
    priority = {2},
    title = {{Model-driven software verification}},
    url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.112.1504},
    year = {2004}
}

@incollection{Holzmann2008New,
    abstract = {{In the last 25 years, the notion of performing software verification with logic model checking techniques has evolved from intellectual curiosity to accepted technology with significant potential for broad practical application. In this paper we look back at the main steps in this evolution and illustrate how the challenges have changed over the years, as we sharpened our theories and tools. Next we discuss a typical challenge in software verification that we face today --- and that perhaps we can look back on in another 25 years as having inspired the next logical step towards a broader integration of model checking into the software development process.}},
    address = {Berlin, Heidelberg},
    author = {Holzmann, Gerard J. and Joshi, Rajeev and Groce, Alex},
    booktitle = {25 Years of Model Checking},
    chapter = {New Challenges in Model Checking},
    citeulike-article-id = {10716813},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=1423539},
    citeulike-linkout-1 = {http://dx.doi.org/10.1007/978-3-540-69850-0\_4},
    comment = {paper\_depo/25MC.pdf},
    doi = {10.1007/978-3-540-69850-0\_4},
    editor = {Grumberg, Orna and Veith, Helmut},
    isbn = {978-3-540-69849-4},
    journal = {25 Years of Model Checking},
    keywords = {formal\_methods},
    pages = {65--76},
    posted-at = {2012-05-30 01:13:19},
    priority = {2},
    publisher = {Springer-Verlag},
    title = {{New Challenges in Model Checking}},
    url = {http://dx.doi.org/10.1007/978-3-540-69850-0\_4},
    year = {2008}
}

@inproceedings{Witkowski2007Model,
    abstract = {{The S<scp>lam</scp> toolkit demonstrates that predicate abstraction enables automated verification of real world Windows device drivers. Our predicate abstraction-based tool DDV<scp>erify</scp>enables the automated verification of Linux device drivers and provides an accurate model of the relevant parts of the kernel. We report on benchmarks based on Linux device drivers, confirming the results that S<scp>lam</scp> established for the Windows world. Furthermore, we take predicate abstraction one step further and introduce a technique to verify concurrent software with shared memory}},
    address = {New York, NY, USA},
    author = {Witkowski, Thomas and Blanc, Nicolas and Kroening, Daniel and Weissenbacher, Georg},
    booktitle = {Proceedings of the twenty-second IEEE/ACM international conference on Automated software engineering},
    citeulike-article-id = {10713663},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=1321719},
    citeulike-linkout-1 = {http://dx.doi.org/10.1145/1321631.1321719},
    comment = {paper\_depo/p501-witkowski.pdf},
    doi = {10.1145/1321631.1321719},
    isbn = {978-1-59593-882-4},
    keywords = {formal\_methods},
    location = {Atlanta, Georgia, USA},
    pages = {501--504},
    posted-at = {2012-05-29 05:09:03},
    priority = {2},
    publisher = {ACM},
    series = {ASE '07},
    title = {{Model checking concurrent linux device drivers}},
    url = {http://dx.doi.org/10.1145/1321631.1321719},
    year = {2007}
}

@inproceedings{Cimatti2002NuSMV,
    abstract = {{An abstract is not available.}},
    address = {London, UK, UK},
    author = {Cimatti, Alessandro and Clarke, Edmund M. and Giunchiglia, Enrico and Giunchiglia, Fausto and Pistore, Marco and Roveri, Marco and Sebastiani, Roberto and Tacchella, Armando},
    booktitle = {Proceedings of the 14th International Conference on Computer Aided Verification},
    citeulike-article-id = {10713655},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=734431},
    comment = {paper\_depo/cav02.pdf},
    isbn = {3-540-43997-8},
    keywords = {formal\_methods},
    pages = {359--364},
    posted-at = {2012-05-29 05:04:21},
    priority = {2},
    publisher = {Springer-Verlag},
    series = {CAV '02},
    title = {{NuSMV 2: An OpenSource Tool for Symbolic Model Checking}},
    url = {http://portal.acm.org/citation.cfm?id=734431},
    year = {2002}
}

@inproceedings{Gastin2001Fast,
    abstract = {{We present an algorithm to generate B\"{u}chi automata from LTL formulae. This algorithm generates a very weak alternating co-B\"{u}chi automaton and then transforms it into a B\"{u}chi automaton, using a generalized B\"{u}chi automaton as an intermediate step. Each automaton is simplified on-the-fly in order to save memory and time. As usual we simplify the LTL formula before any treatment. We implemented this algorithm and compared it with Spin: the experiments show that our algorithm is much more efficient than Spin. The criteria of comparison are the size of the resulting automaton, the time of the computation and the memory used. Our implementation is available on the web at the following address: http://verif.liafa.jussieu.fr/ltl2ba}},
    address = {London, UK, UK},
    author = {Gastin, Paul and Oddoux, Denis},
    booktitle = {Proceedings of the 13th International Conference on Computer Aided Verification},
    citeulike-article-id = {4190771},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=734262},
    comment = {paper\_depo/10.1.1.126.4074},
    isbn = {3-540-42345-1},
    keywords = {formal\_methods},
    pages = {53--65},
    posted-at = {2012-05-29 05:00:32},
    priority = {2},
    publisher = {Springer-Verlag},
    series = {CAV '01},
    title = {{Fast LTL to B\"{u}chi Automata Translation}},
    url = {http://portal.acm.org/citation.cfm?id=734262},
    year = {2001}
}

@article{Merro2011Timed,
    abstract = {{We propose a timed broadcasting process calculus for wireless systems where time-consuming communications are exposed to collisions. The operational semantics of our calculus is given in terms of a labelled transition system. The calculus enjoys a number of desirable time properties such as (i) time determinism: the passage of time is deterministic; (ii) patience: devices will wait indefinitely until they can communicate; (iii) maximal progress: data transmissions cannot be delayed, they must occur as soon as a possibility for communication arises. We use our calculus to model and study MAC-layer protocols with a special emphasis on collisions and security. The main behavioural equality of our calculus is a timed variant of barbed congruence, a standard branching-time and contextually-defined program equivalence. As an efficient proof method for timed barbed congruence we define a labelled bisimilarity. We then apply our bisimulation proof-technique to prove a number of algebraic laws.}},
    address = {Essex, UK},
    author = {Merro, Massimo and Ballardin, Francesco and Sibilio, Eleonora},
    citeulike-article-id = {9631024},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=2039634},
    citeulike-linkout-1 = {http://dx.doi.org/10.1016/j.tcs.2011.07.016},
    comment = {paper\_depo/Merro2011Timed.pdf},
    doi = {10.1016/j.tcs.2011.07.016},
    issn = {0304-3975},
    journal = {Theor. Comput. Sci.},
    month = nov,
    number = {47},
    pages = {6585--6611},
    posted-at = {2012-05-29 04:54:23},
    priority = {2},
    publisher = {Elsevier Science Publishers Ltd.},
    title = {{A timed calculus for wireless systems}},
    url = {http://dx.doi.org/10.1016/j.tcs.2011.07.016},
    volume = {412},
    year = {2011}
}

@book{Milner1982Calculus,
    abstract = {{An abstract is not available.}},
    address = {Secaucus, NJ, USA},
    author = {Milner, R.},
    citeulike-article-id = {3055332},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=539036},
    comment = {Cannot find the book.},
    isbn = {0387102353},
    keywords = {formal\_methods},
    posted-at = {2012-05-29 04:48:26},
    priority = {2},
    publisher = {Springer-Verlag New York, Inc.},
    title = {{A Calculus of Communicating Systems}},
    url = {http://portal.acm.org/citation.cfm?id=539036},
    year = {1982}
}

@inproceedings{Vargas2009Model,
    abstract = {{The Raise Specification Language (RSL) is a modeling language which supports various specification styles. To apply model checking to RSL concurrent descriptions, we translate RSL specifications into the input language CSPM of FDR. FDR is the model checker for the process algebra CSP. First, we define a syntactic and semantic translation from the concurrent applicative subset of RSL to CSPM, and show that this translation is a strong bisimulation which preserves properties such as traces and deadlock. Consequently, results obtained by refinement checks in FDR are sound for the original RSL descriptions. Second, RSL uses Linear Temporal Logic (LTL) to specify desired properties, but FDR does not support LTL. LTL formulas may be translated to CSP test processes in order to check them with FDR. We build a tool which automates the translation of RSL specifications into CSPM and translates LTL formulas to CSP processes, enabling the model checking of LTL formulas over RSL descriptions with FDR.}},
    address = {Berlin, Heidelberg},
    author = {Vargas, Abigail P. and Garis, Ana G. and Tarifa, S. Lizeth and George, Chris},
    booktitle = {Proceedings of the 7th International Conference on Integrated Formal Methods},
    citeulike-article-id = {10713605},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=1506954},
    citeulike-linkout-1 = {http://dx.doi.org/10.1007/978-3-642-00255-7\_16},
    comment = {paper\_depo/Vargas2009Model.pdf},
    doi = {10.1007/978-3-642-00255-7\_16},
    isbn = {978-3-642-00254-0},
    keywords = {formal\_methods},
    location = {D\&\#252;sseldorf, Germany},
    pages = {231--245},
    posted-at = {2012-05-29 04:40:57},
    priority = {2},
    publisher = {Springer-Verlag},
    series = {IFM '09},
    title = {{Model Checking LTL Formulae in RAISE with FDR}},
    url = {http://dx.doi.org/10.1007/978-3-642-00255-7\_16},
    year = {2009}
}

@incollection{Roscoe1994Modelchecking,
    abstract = {{An abstract is not available.}},
    address = {Hertfordshire, UK, UK},
    author = {Roscoe, A. W.},
    booktitle = {A classical mind: essays in honour of C. A. R. Hoare},
    chapter = {Model-Checking CSP},
    citeulike-article-id = {9760197},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=197628},
    comment = {paper\_depo/Roscoe1994Modelchecking.ps
paper\_depo/Roscoe1994Modelchecking.pdf},
    editor = {Roscoe, A. W.},
    isbn = {0-13-294844-3},
    keywords = {formal\_methods},
    pages = {353--378},
    posted-at = {2012-05-29 04:31:14},
    priority = {2},
    publisher = {Prentice Hall International (UK) Ltd.},
    title = {{Model-Checking CSP}},
    url = {http://portal.acm.org/citation.cfm?id=197628},
    year = {1994}
}

@article{Peled1994Combining,
    abstract = {{Abstract Partial order model-checking is an approach to reduce time and memory in modelchecking concurrent programs. On-the-fly model-checking is a technique to eliminate part of the search by intersecting an automaton representing the (negation of the) checked property with the state space during its generation. We prove conditions under which these two methods can be combined in order to gain reduction from both methods. An extension of the model-checker SPIN, which implements this combination, is studied, showing substantial reduction over traditional search, not only in the number of reachable states, but directly in the amount of memory and time used. We also describe how to apply partial-order model-checking under given fairness assumptions.}},
    author = {Peled, Doron},
    citeulike-article-id = {10713578},
    citeulike-linkout-0 = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.136.1002},
    comment = {paper\_depo/10.1.1.136.1002.pdf},
    keywords = {formal\_methods},
    pages = {377--390},
    posted-at = {2012-05-29 04:15:32},
    priority = {2},
    title = {{Combining Partial Order Reductions with On-the-fly Model-checking}},
    url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.136.1002},
    year = {1994}
}

@phdthesis{McMillan1992Symbolic,
    abstract = {{An abstract is not available.}},
    address = {Pittsburgh, PA, USA},
    author = {McMillan, Kenneth L.},
    citeulike-article-id = {10527043},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=143233},
    comment = {paper\_depo/GetTRDoc.pdf},
    keywords = {formal\_methods},
    posted-at = {2012-05-29 04:10:24},
    priority = {2},
    publisher = {Carnegie Mellon University},
    title = {{Symbolic model checking: an approach to the state explosion problem}},
    url = {http://portal.acm.org/citation.cfm?id=143233},
    year = {1992}
}

@article{Hoare2004Communicating,
    abstract = {{CiteSeerX - Document Details (Isaac Councill, Lee Giles):}},
    author = {Hoare, C. A. R.},
    citeulike-article-id = {4308548},
    citeulike-linkout-0 = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.85.2760},
    comment = {book/cspbook.pdf},
    journal = {Communications of the ACM},
    keywords = {formal\_methods},
    pages = {666--677},
    posted-at = {2012-05-29 04:02:53},
    priority = {2},
    title = {{Communicating Sequential Processes}},
    url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.85.2760},
    volume = {21},
    year = {2004}
}

@inproceedings{Godefroid1991Using,
    abstract = {{An abstract is not available.}},
    address = {London, UK, UK},
    author = {Godefroid, Patrice},
    booktitle = {Proceedings of the 2nd International Workshop on Computer Aided Verification},
    citeulike-article-id = {10713321},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=735044},
    comment = {paper\_depo/Godefroid1991Using.pdf},
    isbn = {3-540-54477-1},
    keywords = {formal\_methods},
    pages = {176--185},
    posted-at = {2012-05-29 03:54:26},
    priority = {2},
    publisher = {Springer-Verlag},
    series = {CAV '90},
    title = {{Using Partial Orders to Improve Automatic Verification Methods}},
    url = {http://portal.acm.org/citation.cfm?id=735044},
    year = {1991}
}

@article{Ramananandro2007Mondex,
    abstract = {{This paper explains how the Alloy model-finding method has been used to check the specification of an electronic purse (also called smart card) system, called the Mondex case study, initially written in Z. After describing the payment protocol between two electronic purses, and presenting an overview of the Alloy model-finding method, this paper explains how technical issues about integers and conceptual issues about the object layout in Z have been tackled in Alloy, giving general methods that can be used in most case studies with Alloy. This work has also pointed out some significant bugs in the original Z specification such as reasoning bugs in the proofs, and proposes a way to solve them.}},
    address = {London, UK, UK},
    author = {Ramananandro, Tahina},
    citeulike-article-id = {2152799},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=1341234},
    citeulike-linkout-1 = {http://dx.doi.org/10.1007/s00165-007-0058-z},
    comment = {paper\_depo/Ramananandro2007Mondex.pdf},
    doi = {10.1007/s00165-007-0058-z},
    issn = {0934-5043},
    journal = {Form. Asp. Comput.},
    keywords = {formal\_methods},
    month = dec,
    number = {1},
    pages = {21--39},
    posted-at = {2012-05-29 03:34:06},
    priority = {2},
    publisher = {Springer-Verlag},
    title = {{Mondex, an electronic purse: specification and refinement checks with the <i>Alloy</i> model-finding method}},
    url = {http://dx.doi.org/10.1007/s00165-007-0058-z},
    volume = {20},
    year = {2007}
}

@article{Jackson2002Alloy,
    abstract = {{Alloy is a little language for describing structural properties. It offers a declaration syntax compatible with graphical object models, and a set-based formula syntax powerful enough to express complex constraints and yet amenable to a fully automatic semantic analysis. Its meaning is given by translation to an even smaller (formally defined) kernel. This paper presents the language in its entirety, and explains its motivation, contributions and deficiencies.}},
    address = {New York, NY, USA},
    author = {Jackson, Daniel},
    citeulike-article-id = {690911},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=505149},
    citeulike-linkout-1 = {http://dx.doi.org/10.1145/505145.505149},
    comment = {paper\_depo/p256-jackson.pdf},
    doi = {10.1145/505145.505149},
    issn = {1049-331X},
    journal = {ACM Trans. Softw. Eng. Methodol.},
    keywords = {programming\_language},
    month = apr,
    number = {2},
    pages = {256--290},
    posted-at = {2012-05-29 03:28:03},
    priority = {2},
    publisher = {ACM},
    title = {{Alloy: a lightweight object modelling notation}},
    url = {http://dx.doi.org/10.1145/505145.505149},
    volume = {11},
    year = {2002}
}

@inproceedings{Jackson1998Intermediate,
    abstract = {{A simple relational language is presented that has two desirable properties. First, it is sufficiently expressive to encode, fairly naturally, a variety of software design problems. Second, it is amenable to fully automatic analysis. This paper explains the language and its semantics, and describes a new analysis scheme (based on a stochastic boolean solver) that dramatically outperforms existing schemes.}},
    address = {New York, NY, USA},
    author = {Jackson, Daniel},
    booktitle = {Proceedings of the 6th ACM SIGSOFT international symposium on Foundations of software engineering},
    citeulike-article-id = {10713291},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=288282},
    citeulike-linkout-1 = {http://dx.doi.org/10.1145/288195.288282},
    comment = {paper\_depo/10.1.1.13.677.pdf},
    doi = {10.1145/288195.288282},
    isbn = {1-58113-108-9},
    keywords = {programming\_language},
    location = {Lake Buena Vista, Florida, United States},
    pages = {121--130},
    posted-at = {2012-05-29 03:24:40},
    priority = {2},
    publisher = {ACM},
    series = {SIGSOFT '98/FSE-6},
    title = {{An intermediate design language and its analysis}},
    url = {http://dx.doi.org/10.1145/288195.288282},
    year = {1998}
}

@article{Clarke1994Model,
    abstract = {{We describe a method for using abstraction to reduce the complexity of temporal-logic model checking. Using techniques similar to those involved in abstract interpretation, we construct an abstract model of a program without ever examining the corresponding unabstracted model. We show how this abstract model can be used to verify properties of the original program. We have implemented a system based on these techniques, and we demonstrate their practicality using a number of examples, including a program representing a pipelined ALU circuit with over 101300 states.}},
    address = {New York, NY, USA},
    author = {Clarke, Edmund M. and Grumberg, Orna and Long, David E.},
    citeulike-article-id = {1234715},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=186051},
    citeulike-linkout-1 = {http://dx.doi.org/10.1145/186025.186051},
    comment = {paper\_depo/p1512-clarke.pdf},
    doi = {10.1145/186025.186051},
    issn = {0164-0925},
    journal = {ACM Trans. Program. Lang. Syst.},
    keywords = {formal\_methods},
    month = sep,
    number = {5},
    pages = {1512--1542},
    posted-at = {2012-05-26 02:20:07},
    priority = {2},
    publisher = {ACM},
    title = {{Model checking and abstraction}},
    url = {http://dx.doi.org/10.1145/186025.186051},
    volume = {16},
    year = {1994}
}

@inproceedings{Biere1999Symbolic,
    abstract = {{Symbolic Model Checking [3, 14] has proven to be a powerful technique for the verification of reactive systems. BDDs [2] have traditionally been used as a symbolic representation of the system. In this paper we show how boolean decision procedures, like St\r{a}lmarck's Method [16] or the Davis \& Putnam Procedure [7], can replace BDDs. This new technique avoids the space blow up of BDDs, generates counterexamples much faster, and sometimes speeds up the verification. In addition, it produces counterexamples of minimal length. We introduce a bounded model checking procedure for LTL which reduces model checking to propositional satisfiability. We show that bounded LTL model checking can be done without a tableau construction. We have implemented a model checker BMC, based on bounded model checking, and preliminary results are presented.}},
    address = {London, UK},
    author = {Biere, Armin and Cimatti, Alessandro and Clarke, Edmund M. and Zhu, Yunshan},
    booktitle = {Proceedings of the 5th International Conference on Tools and Algorithms for Construction and Analysis of Systems},
    citeulike-article-id = {824952},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=691738},
    comment = {paper\_depo/BiereCimattiClarkeZhu-TACAS99.pdf},
    isbn = {3-540-65703-7},
    keywords = {formal\_methods},
    pages = {193--207},
    posted-at = {2012-05-26 02:09:46},
    priority = {2},
    publisher = {Springer-Verlag},
    series = {TACAS '99},
    title = {{Symbolic Model Checking without BDDs}},
    url = {http://portal.acm.org/citation.cfm?id=691738},
    year = {1999}
}

@incollection{Queille1982Specification,
    abstract = {{The aim of this paper is to illustrate by an example, the alternating bit protocol, the use of CESAR, an interactive system for aiding the design of distributed applications.}},
    author = {Queille, J. and Sifakis, J.},
    booktitle = {International Symposium on Programming},
    citeulike-article-id = {2882655},
    citeulike-linkout-0 = {http://dx.doi.org/10.1007/3-540-11494-7\_22},
    citeulike-linkout-1 = {http://dx.doi.org/10.1007/3-540-11494-7\_22},
    citeulike-linkout-2 = {http://www.springerlink.com/content/7x327643572334rw},
    comment = {paper\_depo/Queille1982Specification.pdf},
    doi = {10.1007/3-540-11494-7\_22},
    journal = {International Symposium on Programming},
    keywords = {formal\_methods},
    pages = {337--351},
    posted-at = {2012-05-26 01:36:14},
    priority = {2},
    title = {{Specification and verification of concurrent systems in CESAR}},
    url = {http://dx.doi.org/10.1007/3-540-11494-7\_22},
    year = {1982}
}

@incollection{Clarke1982Design,
    abstract = {{We have shown that it is possible to automatically synthesize the synchronization skeleton of a concurrent program from a Temporal Logic specification. We believe that this approach may in the long run turn out to be quite practical. Since synchronization skeletons are, in general, quite small, the potentially exponential behavior of our algorithm need not be an insurmountable obstacle. Much additional research will be needed, however, to make the approach feasible in practice.}},
    address = {Berlin/Heidelberg},
    author = {Clarke, Edmund and Emerson, E.},
    booktitle = {Logics of Programs},
    chapter = {5},
    citeulike-article-id = {1787453},
    citeulike-linkout-0 = {http://dx.doi.org/10.1007/BFb0025774},
    citeulike-linkout-1 = {http://www.springerlink.com/content/w1778u28166t2677},
    comment = {paper\_depo/Clarke1982Design.pdf},
    doi = {10.1007/BFb0025774},
    editor = {Kozen, Dexter},
    isbn = {3-540-11212-X},
    journal = {Logics of Programs},
    keywords = {logic},
    pages = {52--71},
    posted-at = {2012-05-26 01:31:50},
    priority = {2},
    publisher = {Springer Berlin / Heidelberg},
    series = {Lecture Notes in Computer Science},
    title = {{Design and synthesis of synchronization skeletons using branching time temporal logic}},
    url = {http://dx.doi.org/10.1007/BFb0025774},
    volume = {131},
    year = {1982}
}

@incollection{Clarke2008Birth,
    abstract = {{"When the time is ripe for certain things, these things appear in different places in the manner of violets coming to light in early spring." (Wolfgang Bolyai to his son Johann in urging him to claim the invention of non- Euclidean geometry without delay [Vit88]).}},
    address = {Berlin, Heidelberg},
    author = {Clarke, Edmund M.},
    booktitle = {25 Years of Model Checking},
    chapter = {The Birth of Model Checking},
    citeulike-article-id = {3372907},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=1423536},
    citeulike-linkout-1 = {http://dx.doi.org/10.1007/978-3-540-69850-0\_1},
    citeulike-linkout-2 = {http://www.springerlink.com/content/j335v4472745r366},
    doi = {10.1007/978-3-540-69850-0\_1},
    editor = {Grumberg, Orna and Veith, Helmut},
    isbn = {978-3-540-69849-4},
    journal = {25 Years of Model Checking},
    keywords = {formal\_methods},
    pages = {1--26},
    posted-at = {2012-05-26 01:28:21},
    priority = {5},
    publisher = {Springer Berlin / Heidelberg},
    series = {Lecture Notes in Computer Science},
    title = {{The Birth of Model Checking}},
    url = {http://dx.doi.org/10.1007/978-3-540-69850-0\_1},
    volume = {5000},
    year = {2008}
}

@inproceedings{Vardi1984Automata,
    abstract = {{We present a new technique for obtaining decision procedures for modal logics of programs. The technique centers around a new class of finite automata on infinite trees for which the emptiness problem can be solved in polynomial time. The decision procedures then consist of constructing an automaton Af for a given formula f, such that Af accepts some tree if and only if f is satisfiable. We illustrate our technique by giving an exponential decision procedure for deterministic propositional dynamic logic and a variant of the \&mgr-calculus of Kozen.}},
    address = {New York, NY, USA},
    author = {Vardi, Moshe Y. and Wolper, Pierre},
    booktitle = {Proceedings of the sixteenth annual ACM symposium on Theory of computing},
    citeulike-article-id = {10704895},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=808711},
    citeulike-linkout-1 = {http://dx.doi.org/10.1145/800057.808711},
    comment = {paper\_depo/p446-vardi.pdf},
    doi = {10.1145/800057.808711},
    isbn = {0-89791-133-4},
    keywords = {formal\_methods},
    pages = {446--456},
    posted-at = {2012-05-26 01:20:55},
    priority = {2},
    publisher = {ACM},
    series = {STOC '84},
    title = {{Automata theoretic techniques for modal logics of programs: (Extended abstract)}},
    url = {http://dx.doi.org/10.1145/800057.808711},
    year = {1984}
}

@article{Emerson1986Sometimes,
    abstract = {{The differences between and appropriateness of branching versus linear time temporal logic for reasoning about concurrent programs are studied. These issues have been previously considered by Lamport. To facilitate a careful examination of these issues, a language, CTL * , in which a universal or existential path quantifier can prefix an arbitrary linear time assertion, is defined. The expressive power of a number of sublanguages is then compared. CTL* is also related to the logics MPL of Abrahamson and PL of Harel, Kozen, and Parikh. The paper concludes with a comparison of the utility of branching and linear time temporal logics.}},
    address = {New York, NY, USA},
    author = {Emerson, Allen E. and Halpern, Joseph Y.},
    citeulike-article-id = {697230},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=4904.4999},
    citeulike-linkout-1 = {http://dx.doi.org/10.1145/4904.4999},
    comment = {paper\_depo/p151-emerson.pdf},
    doi = {10.1145/4904.4999},
    issn = {0004-5411},
    journal = {J. ACM},
    keywords = {logic},
    month = jan,
    number = {1},
    pages = {151--178},
    posted-at = {2012-05-26 01:14:14},
    priority = {2},
    publisher = {ACM},
    title = {{"Sometimes" and "not never" revisited: on branching versus linear time temporal logic}},
    url = {http://dx.doi.org/10.1145/4904.4999},
    volume = {33},
    year = {1986}
}

@article{Emerson1985Decision,
    abstract = {{We consider the computation tree logic (CTL) proposed in ( Sci. Comput. Programming 2 (1982), 241–260) which extends the unified branching time logic (UB) of ( ” Proc. Ann. ACM Sympos. Principles of Programming Languages, 1981,” pp. 164–176) by adding an until operator. It is established that CTL has the small model property by showing that any satisfiable CTL formulae is satisfiable in a small finite model obtained from the small  ” pseudomodel” resulting from the Fischer-Ladner quotient construction. Then an exponential time algorithm is given for deciding satisfiability in CTL, and the axiomatization of UB given in ibid. is extended to a complete axiomatization for CTL. Finally, the relative expressive power of a family of temporal logics obtained by extending or restricting the syntax of UB and CTL is studied.}},
    author = {Emerson, E. and Halpern, Joseph Y.},
    citeulike-article-id = {7557934},
    citeulike-linkout-0 = {http://dx.doi.org/10.1016/0022-0000(85)90001-7},
    comment = {paper\_depo/p169-emerson.pdf},
    doi = {10.1016/0022-0000(85)90001-7},
    issn = {00220000},
    journal = {Journal of Computer and System Sciences},
    keywords = {logic},
    month = feb,
    number = {1},
    pages = {1--24},
    posted-at = {2012-05-26 01:07:12},
    priority = {2},
    title = {{Decision procedures and expressiveness in the temporal logic of branching time}},
    url = {http://dx.doi.org/10.1016/0022-0000(85)90001-7},
    volume = {30},
    year = {1985}
}

@inproceedings{Pnueli1977Temporal,
    abstract = {{A unified approach to program verification is suggested, which applies to both sequential and parallel programs. The main proof method suggested is that of temporal reasoning in which the time dependence of events is the basic concept. Two formal systems are presented for providing a basis for temporal reasoning. One forms a formalization of the method of intermittent assertions, while the other is an adaptation of the tense logic system Kb, and is particularly suitable for reasoning about concurrent programs.}},
    address = {Washington, DC, USA},
    author = {Pnueli, Amir},
    booktitle = {Symposium on Foundations of Computer Science},
    citeulike-article-id = {4406307},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=1382534},
    citeulike-linkout-1 = {http://doi.ieeecomputersociety.org/10.1109/SFCS.1977.32},
    citeulike-linkout-2 = {http://dx.doi.org/10.1109/SFCS.1977.32},
    citeulike-linkout-3 = {http://ieeexplore.ieee.org/xpls/abs\_all.jsp?arnumber=4567924},
    comment = {paper\_depo/542800046.pdf},
    day = {18},
    doi = {10.1109/SFCS.1977.32},
    issn = {0272-5428},
    journal = {Foundations of Computer Science, Annual IEEE Symposium on},
    keywords = {logic, programming\_language},
    location = {Providence, RI, USA},
    month = sep,
    pages = {46--57},
    posted-at = {2012-05-25 00:39:22},
    priority = {2},
    publisher = {IEEE},
    series = {SFCS '77},
    title = {{The Temporal Logic of Programs}},
    url = {http://dx.doi.org/10.1109/SFCS.1977.32},
    volume = {0},
    year = {1977}
}

@inproceedings{Zhu2005Safe,
    abstract = {{The need for direct memory manipulation through pointers is essential  in many applications. However, it is also commonly understood that the use (or  probably misuse) of pointers is often a rich source of program errors. Therefore,  approaches that can effectively enforce safe use of pointers in programming are  highly sought after. ATS is a programming language with a type system rooted in  a recently developed framework Applied Type System, and a novel and desirable  feature in ATS lies in its support for safe programming with pointers through a  novel notion of stateful views. In particular, even pointer arithmetic is allowed  in ATS and guaranteed to be safe by the type system of ATS. In this paper, we  give an overview of this feature in ATS, presenting some interesting examples  based on a prototype implementation of ATS to demonstrate the practicality of  safe programming with pointer through stateful views.}},
    author = {Zhu, Dengping and Xi, Hongwei},
    booktitle = {In Proceedings of the 7th International Symposium on Practical Aspects of Declarative Languages},
    citeulike-article-id = {10694987},
    citeulike-linkout-0 = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.59.5572},
    comment = {paper\_depo/10.1.1.59.5572.pdf},
    keywords = {programming\_language},
    pages = {83--97},
    posted-at = {2012-05-23 04:49:44},
    priority = {2},
    title = {{Safe Programming with Pointers through Stateful Views}},
    url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.59.5572},
    year = {2005}
}

@inproceedings{Condit2007Dependent,
    abstract = {{In this paper, we describe the key principles of a dependent type system for low-level imperative languages. The major contributions of this work are (1) a sound type system that combines dependent types and mutation for variables and for heap-allocated structures in a more flexible way than before and (2) a technique for automatically inferring dependent types for local variables. We have applied these general principles to design Deputy, a dependent type system for C that allows the user to describe bounded pointers and tagged unions. Deputy has been used to annotate and check a number of real-world C programs.}},
    address = {Berlin, Heidelberg},
    author = {Condit, Jeremy and Harren, Matthew and Anderson, Zachary and Gay, David and Necula, George C.},
    booktitle = {Proceedings of the 16th European conference on Programming},
    citeulike-article-id = {10694979},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=1762221},
    comment = {paper\_depo/10.1.1.130.9162.pdf},
    isbn = {978-3-540-71314-2},
    keywords = {programming\_language},
    location = {Braga, Portugal},
    pages = {520--535},
    posted-at = {2012-05-23 04:33:45},
    priority = {2},
    publisher = {Springer-Verlag},
    series = {ESOP'07},
    title = {{Dependent types for low-level programming}},
    url = {http://portal.acm.org/citation.cfm?id=1762221},
    year = {2007}
}

@inproceedings{Jim2002Cyclone,
    abstract = {{An abstract is not available.}},
    address = {Berkeley, CA, USA},
    author = {Jim, Trevor and Morrisett, J. Greg and Grossman, Dan and Hicks, Michael W. and Cheney, James and Wang, Yanling},
    booktitle = {Proceedings of the General Track of the annual conference on USENIX Annual Technical Conference},
    citeulike-article-id = {10694976},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=647057.713871},
    comment = {paper\_depo/10.1.1.127.7825.pdf},
    isbn = {1-880446-00-6},
    keywords = {programming\_language},
    pages = {275--288},
    posted-at = {2012-05-23 04:29:11},
    priority = {2},
    publisher = {USENIX Association},
    series = {ATEC '02},
    title = {{Cyclone: A Safe Dialect of C}},
    url = {http://portal.acm.org/citation.cfm?id=647057.713871},
    year = {2002}
}

@incollection{Henglein2005Effect,
    abstract = {{No abstract available.}},
    author = {Henglein, Fritz and Makholm, Henning and Niss, Henning},
    booktitle = {Advanced Topics in Types and Programming Languages},
    chapter = {5},
    citeulike-article-id = {10694972},
    comment = {book/Advanced Topics in Types and Programming Languages (2005).pdf},
    editor = {Pierce, Benjamin C.},
    keywords = {reading\_list},
    pages = {230--273},
    posted-at = {2012-05-23 04:22:10},
    priority = {2},
    title = {{Effect Types and Region-Based Memory Management}},
    year = {2005}
}

@article{Cervesato1996Linear,
    abstract = {{We present the linear type theory LLF as the forAppeared in the proceedings of the Eleventh Annual IEEE Symposium on Logic in Computer Science --- LICS'96 (E. Clarke editor), pp. 264--275, New Brunswick, NJ, July 27--30 1996.  mal basis for a conservative extension of the LF logical framework. LLF combines the expressive power of dependent types with linear logic to permit the natural and concise representation of a whole new class of deductive systems, namely those dealing with state. As an example we encode a version of Mini-ML with references including its type system, its operational semantics, and a proof of type preservation. Another example is the encoding of a sequent calculus for classical linear logic and its cut elimination theorem. LLF can also be given an operational interpretation as a logic programming language under which the representations above can be used for type inference, evaluation and cut-elimination. 1 Introduction  A logical framework is a formal system desig...}},
    author = {Cervesato, Iliano and Pfenning, Frank},
    citeulike-article-id = {10694970},
    citeulike-linkout-0 = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.21.1152},
    comment = {paper\_depo/10.1.1.21.1152.pdf},
    keywords = {programming\_language},
    pages = {264--275},
    posted-at = {2012-05-23 04:21:11},
    priority = {2},
    title = {{A Linear Logical Framework}},
    url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.21.1152},
    year = {1996}
}

@incollection{Harper1987Framework,
    abstract = {{The Edinburgh Logical Framework (LF) provides a means to define (or present) logics. It is based on a general treatment of syntax, rules, and proofs by means of a typed -calculus with dependent types. Syntax is treated in a style similar to, but more general than, Martin-L\"{o}f's system of arities. The treatment of rules and proofs focuses on his notion of a judgement. Logics are represented in LF via a new principle, the judgements as types principle, whereby each judgement is identified with the ...}},
    address = {New York},
    author = {Harper, Robert and Honsell, Furio and Plotkin, Gordon},
    booktitle = {Proceedings 2nd Annual IEEE Symp.\ on Logic in Computer Science, {LICS}'87, Ithaca, {NY}, {USA}, 22--25 June 1987},
    citeulike-article-id = {416168},
    citeulike-linkout-0 = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.41.9088},
    comment = {paper\_depo/10.1.1.41.9088.pdf},
    keywords = {programming\_language},
    pages = {194--204},
    posted-at = {2012-05-23 04:12:55},
    priority = {2},
    publisher = {IEEE Computer Society Press},
    title = {{A Framework for Defining Logics}},
    url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.41.9088},
    year = {1987}
}

@article{Reynolds2002Separation,
    abstract = {{In joint work with Peter O'Hearn and others, based on early ideas of Burstall, we have developed an extension of Hoare logic that permits reasoning about low-level imperative  programs that use shared mutable data structure.  The simple imperative programming language is extended with commands (not expressions) for accessing and modifying shared structures, and for explicit allocation and deallocation of storage. Assertions are extended by introducing a "separating conjunction" that asserts that its sub-formulas hold for disjoint parts of the heap, and a closely related "separating implication". Coupled with the inductive definition of predicates on abstract data structures, this extension permits the concise and flexible description of structures with controlled sharing.  In this paper, we will survey the current development of this program logic, including extensions that permit unrestricted address arithmetic, dynamically allocated arrays, and recursive procedures. We will also discuss promising future directions.}},
    address = {Los Alamitos, CA, USA},
    author = {Reynolds, John C.},
    citeulike-article-id = {307599},
    citeulike-linkout-0 = {http://doi.ieeecomputersociety.org/10.1109/LICS.2002.1029817},
    citeulike-linkout-1 = {http://dx.doi.org/10.1109/LICS.2002.1029817},
    citeulike-linkout-2 = {http://ieeexplore.ieee.org/xpls/abs\_all.jsp?arnumber=1029817},
    comment = {paper\_depo/14830055.pdf},
    doi = {10.1109/LICS.2002.1029817},
    issn = {1043-6871},
    journal = {Logic in Computer Science, Symposium on},
    keywords = {programming\_language},
    pages = {55--74},
    posted-at = {2012-05-23 03:59:04},
    priority = {2},
    publisher = {IEEE Computer Society},
    title = {{Separation Logic: A Logic for Shared Mutable Data Structures}},
    url = {http://dx.doi.org/10.1109/LICS.2002.1029817},
    volume = {0},
    year = {2002}
}

@inproceedings{Xi2004Applied,
    abstract = {{Abstract. The framework Pure Type System (PTS) offers a simple and general approach to designing and formalizing type systems. However, in the presence of dependent types, there often exist some acute problems that make it difficult for PTS to accommodate many common realistic programming features such as general recursion, recursive types, effects (e.g., exceptions, references, input/output), etc. In this paper, we propose a new framework Applied Type System (ATS) to allow for designing and formalizing type systems that can readily support common realistic programming features. The key salient feature of ATS lies in a complete separation between statics, in which types are formed and reasoned about, and dynamics, in which programs are constructed and evaluated. With this separation, it is no longer possible for a program to occur in a type as is otherwise allowed in PTS. We present not only a formal development of ATS but also mention some examples in support of using ATS as a framework to form type systems for practical programming. 1}},
    author = {Xi, Hongwei},
    booktitle = {In post-workshop Proceedings of TYPES 2003},
    citeulike-article-id = {10694959},
    citeulike-linkout-0 = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.69.3644},
    comment = {paper\_depo/10.1.1.69.3644.pdf},
    keywords = {programming\_language},
    pages = {394--408},
    posted-at = {2012-05-23 03:57:20},
    priority = {2},
    title = {{Applied Type System (extended abstract}},
    url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.69.3644},
    year = {2004}
}

@inbook{Barendregt1984Lambda,
    abstract = {{The revised edition contains a new chapter which provides an elegant description of the semantics. The various classes of lambda calculus models are described in a uniform manner. Some didactical improvements have been made to this edition. An example of a simple model is given and then the general theory (of categorical models) is developed. Indications are given of those parts of the book which can be used to form a coherent course.}},
    author = {Barendregt, H. P.},
    chapter = {1-7, 11},
    citeulike-article-id = {679666},
    citeulike-linkout-0 = {http://www.amazon.ca/exec/obidos/redirect?tag=citeulike09-20\&amp;path=ASIN/0444875085},
    citeulike-linkout-1 = {http://www.amazon.de/exec/obidos/redirect?tag=citeulike01-21\&amp;path=ASIN/0444875085},
    citeulike-linkout-2 = {http://www.amazon.fr/exec/obidos/redirect?tag=citeulike06-21\&amp;path=ASIN/0444875085},
    citeulike-linkout-3 = {http://www.amazon.jp/exec/obidos/ASIN/0444875085},
    citeulike-linkout-4 = {http://www.amazon.co.uk/exec/obidos/ASIN/0444875085/citeulike00-21},
    citeulike-linkout-5 = {http://www.amazon.com/exec/obidos/redirect?tag=citeulike07-20\&path=ASIN/0444875085},
    citeulike-linkout-6 = {http://www.worldcat.org/isbn/0444875085},
    citeulike-linkout-7 = {http://books.google.com/books?vid=ISBN0444875085},
    citeulike-linkout-8 = {http://www.amazon.com/gp/search?keywords=0444875085\&index=books\&linkCode=qs},
    citeulike-linkout-9 = {http://www.librarything.com/isbn/0444875085},
    day = {15},
    edition = {Revised},
    howpublished = {Paperback},
    isbn = {0444875085},
    keywords = {programming\_language},
    month = nov,
    posted-at = {2012-05-23 03:48:58},
    priority = {2},
    publisher = {Elsevier},
    title = {{The Lambda Calculus: Its Syntax and Semantics}},
    url = {http://www.worldcat.org/isbn/0444875085},
    year = {1984}
}

@inproceedings{Tarditi1995TIL,
    abstract = {{We describe a new compiler for Standard ML called TIL, that is based on four technologies: intensional polymorphism, tag-free garbage collection, conventional functional language optimization, and loop optimization. We use intensional polymorphism and tag-free garbage collection to provide specialized representations, even though SML is a polymorphic language. We use conventional functional language optimization to reduce the cost of intensional polymorphism, and loop optimization to generate good code for recursive functions. We present an example of TIL compiling an SML function to machine code, and compare the performance of TIL code against that of a widely used compiler, Standard ML of New Jersey.}},
    author = {Tarditi, David and Morrisett, Greg and Cheng, Perry and Stone, Chris and Harper, Robert and Lee, Peter},
    booktitle = {ACM SIGPLAN conference on Programming Language Design and Implementation},
    citeulike-article-id = {7952602},
    citeulike-linkout-0 = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.27.353},
    comment = {paper\_depo/10.1.1.27.353.pdf},
    keywords = {programming\_language},
    pages = {181--192},
    posted-at = {2012-05-23 03:43:15},
    priority = {2},
    title = {{TIL: A Type-Directed Optimizing Compiler for ML}},
    url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.27.353},
    year = {1995}
}

@incollection{Wadler1989Theorems,
    abstract = {{From the type of a polymorphic function we can derive
a theorem that it satisfies. Every function of the
same type satisfies the same theorem. This provides
a free source of useful theorems, courtesy of Reynolds'
abstraction theorem for the polymorphic lambda calculus.

1 Introduction

Write down the definition of a polymorphic function on
a piece of paper. Tell me its type, but be careful not
to let me see the function's definition. I will tell you a
theorem that the function satisfies.
The...}},
    address = {New York},
    author = {Wadler, Philip},
    booktitle = {Proceedings 4th Int.\ Conf.\ on Funct.\ Prog.\ Languages and Computer Arch., FPCA'89, London, {UK}, 11--13 Sept 1989},
    citeulike-article-id = {1848264},
    citeulike-linkout-0 = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.38.9875},
    comment = {paper\_depo/10.1.1.38.9875.pdf},
    keywords = {programming\_language},
    pages = {347--359},
    posted-at = {2012-05-23 03:40:31},
    priority = {2},
    publisher = {ACM Press},
    title = {{Theorems for Free!}},
    url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.38.9875},
    year = {1989}
}

@incollection{Harper2005Design,
    abstract = {{No abstract available.}},
    author = {Harper, Robert and Piece, Benjamin C.},
    booktitle = {Advanced Topics in Types and Programming Languages},
    chapter = {9},
    citeulike-article-id = {10694945},
    comment = {book/Advanced Topics in Types and Programming Languages (2005).pdf},
    editor = {Pierce, Benjamin C.},
    keywords = {reading\_list},
    pages = {393--439},
    posted-at = {2012-05-23 03:37:40},
    priority = {2},
    title = {{Design Issues in Advanced Module Systems}},
    year = {2005}
}

@inproceedings{Wadler1989How,
    abstract = {{This paper presents type classes, a new approach to ad-hoc polymorphism. Type classes permit overloading of arithmetic operators such as multiplication, and generalise the  ” eqtype variables” of Standard ML. Type classes extend the Hindley/Milner polymorphic type system, and provide a new approach to issues that arise in object-oriented programming, bounded type quantification, and abstract data types. This paper provides an informal introduction to type classes, and defines them formally by means of type inference rules.}},
    address = {New York, NY, USA},
    author = {Wadler, P. and Blott, S.},
    booktitle = {Proceedings of the 16th ACM SIGPLAN-SIGACT symposium on Principles of programming languages},
    citeulike-article-id = {4958},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=75283},
    citeulike-linkout-1 = {http://dx.doi.org/10.1145/75277.75283},
    comment = {paper\_depo/p60-wadler.pdf},
    doi = {10.1145/75277.75283},
    isbn = {0-89791-294-2},
    keywords = {programming\_language},
    location = {Austin, Texas, United States},
    pages = {60--76},
    posted-at = {2012-05-23 03:34:18},
    priority = {2},
    publisher = {ACM},
    series = {POPL '89},
    title = {{How to make ad-hoc polymorphism less ad hoc}},
    url = {http://dx.doi.org/10.1145/75277.75283},
    year = {1989}
}

@proceedings{Simon1993Imperative,
    abstract = {{We present a new model, based on monads, for performing input/output in a non-strict, purely functional language. It is composable, extensible, efficient, requires no extensions to the type system, and extends smoothly to incorporate mixed-language working and in-place array updates. 1 Introduction Input/output has always appeared to be one of the less satisfactory features of purely functional languages: fitting action into the functional paradigm feels like fitting a square block into a round ...}},
    author = {Simon, S. L. P. and Wadler, Philip},
    booktitle = {Conference record of the Twentieth Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, Charleston, South Carolina},
    citeulike-article-id = {1214},
    citeulike-linkout-0 = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.53.2504},
    comment = {paper\_depo/10.1.1.53.2504.pdf},
    keywords = {programming\_language},
    pages = {71--84},
    posted-at = {2012-05-23 03:30:09},
    priority = {2},
    title = {{Imperative Functional Programming}},
    url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.53.2504},
    year = {1993}
}

@inproceedings{Damas1982Principal,
    abstract = {{An abstract is not available.}},
    address = {New York, NY, USA},
    author = {Damas, Luis and Milner, Robin},
    booktitle = {Proceedings of the 9th ACM SIGPLAN-SIGACT symposium on Principles of programming languages},
    citeulike-article-id = {370442},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=582176},
    citeulike-linkout-1 = {http://dx.doi.org/10.1145/582153.582176},
    comment = {paper\_depo/p207-damas.pdf},
    doi = {10.1145/582153.582176},
    isbn = {0-89791-065-6},
    keywords = {programming\_language},
    location = {Albuquerque, New Mexico},
    pages = {207--212},
    posted-at = {2012-05-23 03:26:51},
    priority = {2},
    publisher = {ACM},
    series = {POPL '82},
    title = {{Principal type-schemes for functional programs}},
    url = {http://dx.doi.org/10.1145/582153.582176},
    year = {1982}
}

@article{Milner1978Theory,
    abstract = {{The aim of this work is largely a practical one. A widely employed style of programming, particularly in structure-processing languages which impose no discipline of types, entails defining procedures which work well on objects of a wide variety. We present a formal type discipline for such polymorphic procedures in the context of a simple programming language, and a compile time type-checking algorithm }},
    author = {Milner, R.},
    citeulike-article-id = {134009},
    citeulike-linkout-0 = {http://dx.doi.org/10.1016/0022-0000(78)90014-4},
    citeulike-linkout-1 = {http://www.sciencedirect.com/science/article/B6WJ0-4B4YSKG-2D/2/64deca1176fc1a45585d3442521fec04},
    comment = {paper\_depo/10.1.1.67.5276.pdf},
    doi = {10.1016/0022-0000(78)90014-4},
    issn = {00220000},
    journal = {Journal of Computer and System Sciences},
    keywords = {programming\_language},
    month = dec,
    number = {3},
    pages = {348--375},
    posted-at = {2012-05-23 03:23:43},
    priority = {2},
    title = {{A theory of type polymorphism in programming}},
    url = {http://dx.doi.org/10.1016/0022-0000(78)90014-4},
    volume = {17},
    year = {1978}
}

@inproceedings{Reynolds1974Towards,
    abstract = {{An abstract is not available.}},
    address = {London, UK, UK},
    author = {Reynolds, John C.},
    booktitle = {Programming Symposium, Proceedings Colloque sur la Programmation},
    citeulike-article-id = {1438},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=721503},
    comment = {paper\_depo/Towards a Theory of Type Structure.pdf},
    isbn = {3-540-06859-7},
    keywords = {programming\_language, type\_theory},
    pages = {408--423},
    posted-at = {2012-05-23 03:13:45},
    priority = {2},
    publisher = {Springer-Verlag},
    title = {{Towards a theory of type structure}},
    url = {http://portal.acm.org/citation.cfm?id=721503},
    year = {1974}
}

@incollection{Walker2005Structural,
    author = {Walker, David},
    booktitle = {Advanced Topics in Types and Programming Languages},
    chapter = {6},
    citeulike-article-id = {10691413},
    comment = {book/Advanced Topics in Types and Programming Languages (2005).pdf},
    editor = {Pierce, Benjamin C.},
    keywords = {reading\_list},
    pages = {274--312},
    posted-at = {2012-05-21 22:02:10},
    priority = {2},
    title = {{Structural Type Systems}},
    year = {2005}
}

@incollection{Aspinall2005Dependent,
    abstract = {{TOP 2003/5/20 page ii TOP 2003/5/20 page iii}},
    author = {Aspinall, David and Hofmann, Martin},
    booktitle = {Advanced Topics in Types and Programming Languages},
    chapter = {4},
    citeulike-article-id = {10691366},
    citeulike-linkout-0 = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.140.2072},
    comment = {book/Advanced Topics in Types and Programming Languages (2005).pdf},
    editor = {Pierce, Benjamin C.},
    keywords = {reading\_list},
    pages = {196--229},
    posted-at = {2012-05-21 21:53:22},
    priority = {2},
    title = {{Dependent Types}},
    url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.140.2072},
    year = {2005}
}

@article{Armstrong2003Making,
    abstract = {{product, having over a million lines of Erlang code. This product (the AXD301) is thought to be one of the most reliable products ever made by Ericsson.}},
    author = {Armstrong, Joe and Helen, To},
    citeulike-article-id = {8972721},
    citeulike-linkout-0 = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.3.408},
    comment = {paper\_depo/10.1.1.3.408.pdf},
    keywords = {programming\_language},
    posted-at = {2012-05-18 23:45:07},
    priority = {4},
    title = {{Making Reliable Distributed Systems in the Presence of Software Errors}},
    url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.3.408},
    year = {2003}
}

@techreport{Schneider87,
    abstract = {{A new proof is given that every property can be expressed as a conjunction of safety and liveness properties. The proof is in terms of first-order predicate logic.}},
    address = {Ithaca, NY, USA},
    author = {Schneider, Fred B.},
    citeulike-article-id = {4502337},
    citeulike-linkout-0 = {http://web.mit.edu/16.399/www/papers/87-874.pdf},
    citeulike-linkout-1 = {http://portal.acm.org/citation.cfm?id=866284},
    comment = {paper\_depo/87-874.pdf},
    institution = {Cornell University},
    keywords = {logic},
    month = oct,
    number = {87-874},
    posted-at = {2012-05-16 04:29:13},
    priority = {2},
    publisher = {Cornell University},
    title = {{Decomposing Properties into Safety and Liveness using Predicate Logic}},
    url = {http://web.mit.edu/16.399/www/papers/87-874.pdf},
    year = {1987}
}

@inproceedings{OhHeLeLeYi12,
    author = {Oh, Hakjoo and Heo, Kihong and Lee, Wonchan and Lee, Woosuk and Yi, Kwangkeun},
    booktitle = {Proceedings of the SIGPLAN Conference on Programming Language Design and Implementation({\\bf PLDI})},
    citeulike-article-id = {10674126},
    comment = {paper\_depo/12-pldi-ohheleleyi.pdf},
    keywords = {formal\_method, verification},
    posted-at = {2012-05-16 00:02:16},
    priority = {5},
    title = {{Design and Implementation of Sparse Global Analyses for C-like Languages}},
    year = {2012}
}

@inproceedings{Stump2008Verified,
    abstract = {{Operational Type Theory (OpTT) is a type theory allowing possibly diverging programs while retaining decidability of type checking and a consistent logic. This is done by distinguishing proofs and (program) terms, as well as formulas and types. The theory features propositional equality on type-free terms, which facilitates reasoning about dependently typed programs. OpTT has been implemented in the Guru verified programming language, which includes a type- and proof-checker, and a compiler to efficient C code. In addition to the core OpTT, Guru implements a number of extensions, including ones for verification of programs using mutable state and input/output. This paper gives an introduction to verified programming in Guru.}},
    address = {New York, NY, USA},
    author = {Stump, Aaron and Deters, Morgan and Petcher, Adam and Schiller, Todd and Simpson, Timothy},
    booktitle = {Proceedings of the 3rd workshop on Programming languages meets program verification},
    citeulike-article-id = {10668846},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=1481856},
    citeulike-linkout-1 = {http://dx.doi.org/10.1145/1481848.1481856},
    comment = {paper\_depo/p49-stump.pdf},
    doi = {10.1145/1481848.1481856},
    isbn = {978-1-60558-330-3},
    keywords = {formal\_methods, type\_theory},
    location = {Savannah, GA, USA},
    pages = {49--58},
    posted-at = {2012-05-14 21:31:41},
    priority = {2},
    publisher = {ACM},
    series = {PLPV '09},
    title = {{Verified programming in Guru}},
    url = {http://dx.doi.org/10.1145/1481848.1481856},
    year = {2008}
}

@inproceedings{Thompson1998Functional,
    abstract = {{This paper uses the Functional Reactive Animation system, Fran, to give a simulation of a simple two floor lift (or elevator). We introduce those aspects of Fran relevant to the simulation, thus making the paper self-contained. We show how to extend the design to one for a lift with an arbitrary number of floors, and we conclude the paper with a discussion of how the Fran simulation can be verified in an informal temporal logic. 1 Introduction  This paper uses the Functional Reactive Animation system -- Fran -- [EH97, PEL97] to give a simulation of a simple lift (or elevator). Fran is a substantial library extending the Haskell [PH97] functional programming language on Windows platforms. The work discussed here has been developed using the Hugs interpreter [Hug98]; compiled support is available using the Glasgow Haskell Compiler [Gla98]. The main architect of the Fran system is Conal Elliott of Microsoft Research, whose previous work has used C++ as a vehicle for similar ideas [E  +  9...}},
    author = {Thompson, Simon},
    booktitle = {Journal of Functional Programming},
    citeulike-article-id = {10628827},
    citeulike-linkout-0 = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.7.2316},
    comment = {paper\_depo/10.1.1.7.2316.pdf},
    keywords = {formal\_methods},
    pages = {1998--583},
    posted-at = {2012-05-02 20:51:40},
    priority = {2},
    title = {{A Functional Reactive Animation of a Lift using Fran}},
    url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.7.2316},
    year = {1998}
}

@inproceedings{Wan2000Functional,
    abstract = {{Functional Reactive Programming, or FRP, is a general framework  for programming hybrid systems in a high-level, declarative manner. The key ideas in FRP are its notions of behaviors  and events. Behaviors are time-varying, reactive values, while events are time-ordered sequences of discrete-time event occurrences. FRP is the essence of Fran, a domainspeci c language embedded in Haskell for programming reactive animations, but FRP is now also being used in vision, robotics and other control systems applications.  In this paper we explore the formal semantics of FRP and how it relates to an implementation based on streams that represent (and therefore only approximate) continuous behaviors. We show that, in the limit as the sampling interval goes to zero, the implementation is faithful to the formal, continuous semantics, but only when certain constraints on behaviors are observed. We explore the nature of these constraints, which vary amongst the FRP primitives. Our results show both the power and limitations of this approach to language design and implementation. As an example of a limitation, we show that streams are incapable of representing instantaneous predicate events over behaviors.  1.}},
    author = {Wan, Zhanyong and Hudak, Paul},
    booktitle = {In ACM SIGPLAN Conference on Programming Language Design and Implementation},
    citeulike-article-id = {3366673},
    citeulike-linkout-0 = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.23.360},
    comment = {paper\_depo/10.1.1.23.360.pdf},
    keywords = {programming\_language},
    pages = {242--252},
    posted-at = {2012-05-01 01:40:42},
    priority = {2},
    title = {{Functional Reactive Programming from First Principles}},
    url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.23.360},
    year = {2000}
}

@inproceedings{Kleine2011LLVM2CSP,
    abstract = {{In this paper, we present the llvm2csp tool which extracts CSP models from the LLVM compiler intermediate representation of concurrent programs. The generation of CSP models is controlled by user annotations and designed to create models of different levels of abstraction for subsequent analysis with standard CSP tools.}},
    address = {Berlin, Heidelberg},
    author = {Kleine, Moritz and Bartels, Bj\"{o}rn and G\"{o}thel, Thomas and Helke, Steffen and Prenzel, Dirk},
    booktitle = {Proceedings of the Third international conference on NASA Formal methods},
    citeulike-article-id = {10623128},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=1986351},
    comment = {paper\_depo/llvm2csp.pdf},
    isbn = {978-3-642-20397-8},
    keywords = {formal\_methods},
    location = {Pasadena, CA},
    pages = {500--505},
    posted-at = {2012-05-01 01:36:15},
    priority = {3},
    publisher = {Springer-Verlag},
    series = {NFM'11},
    title = {{LLVM2CSP: extracting csp models from concurrent programs}},
    url = {http://portal.acm.org/citation.cfm?id=1986351},
    year = {2011}
}

@inproceedings{Zaks2008Verifying,
    abstract = {{A key challenge in model checking software is the difficulty of verifying properties of implementation code, as opposed to checking an abstract algorithmic description. We describe a tool for verifying multi-threaded C programs that uses the SPIN model checker. Our tool works by compiling a multi-threaded C program into a typed bytecode format, and then using a virtual machine that interprets the bytecode and computes new program states under the direction of SPIN. Our virtual machine is compatible with most of SPIN's search options and optimization flags, such as bitstate hashing and multi-core checking. It provides support for dynamic memory allocation (the <Literal>malloc</Literal>and <Literal>free</Literal>family of functions), and for the <Literal>pthread</Literal>library, which provides primitives often used by multi-threaded C programs. A feature of our approach is that it can check code <em>after</em>compiler optimizations, which can sometimes introduce race conditions. We describe how our tool addresses the state space explosion problem by allowing users to define data abstraction functions and to constrain the number of allowed context switches. We also describe a reduction method that reduces context switches using dynamic knowledge computed on-the-fly, while being sound for both safety and liveness properties. Finally, we present initial experimental results with our tool on some small examples.}},
    address = {Berlin, Heidelberg},
    author = {Zaks, Anna and Joshi, Rajeev},
    booktitle = {Proceedings of the 15th international workshop on Model Checking Software},
    chapter = {22},
    citeulike-article-id = {7859757},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=1429102},
    citeulike-linkout-1 = {http://dx.doi.org/10.1007/978-3-540-85114-1\_22},
    citeulike-linkout-2 = {http://www.springerlink.com/content/4540n13ux7g84h61},
    comment = {paper\_depo/spin2008\_submission\_38.pdf
---=note-separator=---
The paper is the successor of <<Model Driven Code Checking>>. It uses SPIN to direct the execution of a virtual machine in which the program is fully verified. All contributions are focusing on dealing with space explosion. 1) reduce data by data abstraction; 2) put constraint on context switch; 3) partial order reduction.},
    doi = {10.1007/978-3-540-85114-1\_22},
    isbn = {978-3-540-85113-4},
    issn = {0302-9743},
    keywords = {formal\_methods},
    location = {Los Angeles, CA, USA},
    pages = {325--342},
    posted-at = {2012-05-01 00:19:57},
    priority = {4},
    publisher = {Springer-Verlag},
    series = {SPIN '08},
    title = {{Verifying Multi-threaded C Programs with SPIN}},
    url = {http://dx.doi.org/10.1007/978-3-540-85114-1\_22},
    volume = {5156},
    year = {2008}
}

@incollection{Kleine2009Formal,
    abstract = {{This paper contributes to the broad field of software verification by proposing a methodology that uses CSP to verify implementations of real-life multithreaded applications. We therefore use CSP to formalize the compiler intermediate representation of a program. Our methodology divides the low-level representation into three parts: an application-specific part, describing the behavior of threads; a domain-specific part, which encapsulates low-level software concepts such as scheduling; and a platform-specific part, which is the hardware model. These three parts form a low-level CSP model that enables us to prove properties, e.g. the absence of race conditions in the model, by either model checking or theorem proving. The application-specific part is synthesized from the LLVM intermediate representation of a multithreaded program.}},
    address = {Berlin, Heidelberg},
    author = {Kleine, Moritz and Helke, Steffen},
    chapter = {Low-Level Code Verification Based on CSP Models},
    citeulike-article-id = {10622041},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=1693678},
    citeulike-linkout-1 = {http://dx.doi.org/10.1007/978-3-642-10452-7\_18},
    comment = {paper\_depo/fulltext\_csp.pdf},
    doi = {10.1007/978-3-642-10452-7\_18},
    editor = {Oliveira, Marcel V. and Woodcock, Jim},
    isbn = {978-3-642-10451-0},
    keywords = {formal\_methods},
    pages = {266--281},
    posted-at = {2012-04-30 21:21:15},
    priority = {3},
    publisher = {Springer-Verlag},
    title = {{Formal Methods: Foundations and Applications}},
    url = {http://dx.doi.org/10.1007/978-3-642-10452-7\_18},
    year = {2009}
}

@inproceedings{Tang2010Trust,
    abstract = {{Current web browsers are complex, have enormous trusted computing bases, and provide attackers with easy access to modern computer systems. In this paper we introduce the Illinois Browser Operating System (IBOS), a new operating system and a new browser that reduces the trusted computing base for web browsers. In our architecture we expose browser-level abstractions at the lowest software layer, enabling us to remove almost all traditional OS components and services from our trusted computing base by mapping browser abstractions to hardware abstractions directly. We show that this architecture is flexible enough to enable new browser security policies, can still support traditional applications, and adds little overhead to the overall browsing experience.}},
    address = {Berkeley, CA, USA},
    author = {Tang, Shuo and Mai, Haohui and King, Samuel T.},
    booktitle = {Proceedings of the 9th USENIX conference on Operating systems design and implementation},
    citeulike-article-id = {10621769},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=1924943.1924945},
    comment = {paper\_depo/tang10\_1.pdf

Webkit, Qt
---=note-separator=---
Build an OS based on L4, which is specially tailored for browser.},
    keywords = {system\_os},
    location = {Vancouver, BC, Canada},
    pages = {1--8},
    posted-at = {2012-04-30 20:16:26},
    priority = {2},
    publisher = {USENIX Association},
    series = {OSDI'10},
    title = {{Trust and protection in the Illinois browser operating system}},
    url = {http://portal.acm.org/citation.cfm?id=1924943.1924945},
    year = {2010}
}

@article{Holzmann2008Model,
    abstract = {{Model checkers were originally developed to support the formal verification of high-level design models of distributed system designs. Over the years, they have become unmatched in precision and performance in this domain. Research in model checking has meanwhile moved towards methods that allow us to reason also about implementation level artifacts (e.g., software code) directly, instead of hand-crafted representations of those artifacts. This does not mean that there is no longer a place for the use of high-level models, but it does mean that such models are used in a different way today. In the approach that we describe here, high-level models are used to represent the environment for which the code is to be verified, but not the application itself. The code of the application is now executed as is by the model checker, while using powerful forms of abstraction on-the-fly to build the abstract state space that guides the verification process. This model-driven code checking method allows us to verify implementation level code efficiently for high-level safety and liveness properties. In this paper, we give an overview of the methodology that supports this new paradigm of code verification.}},
    address = {Hingham, MA, USA},
    author = {Holzmann, Gerard J. and Joshi, Rajeev and Groce, Alex},
    citeulike-article-id = {3644973},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=1459085},
    citeulike-linkout-1 = {http://dx.doi.org/10.1007/s10515-008-0033-9},
    citeulike-linkout-2 = {http://www.springerlink.com/content/pwmh3m5871749q23},
    comment = {paper\_depo/asej08.pdf},
    day = {1},
    doi = {10.1007/s10515-008-0033-9},
    issn = {0928-8910},
    journal = {Automated Software Engg.},
    keywords = {formal\_methods, model\_checking},
    month = dec,
    number = {3-4},
    pages = {283--297},
    posted-at = {2012-04-27 23:35:27},
    priority = {0},
    publisher = {Kluwer Academic Publishers},
    title = {{Model driven code checking}},
    url = {http://dx.doi.org/10.1007/s10515-008-0033-9},
    volume = {15},
    year = {2008}
}

@book{Holzmann2003SPIN,
    abstract = {{Preface ''The worst thing about new books is thatthey keep us from reading the old ones.' '(Joseph Joubert, 1754-1824) A system is correct if it  meets its design requirements. This much is agreed.But if the system we  are designing is a piece of software, especially if itinvolves  concurrency, how can we show this? It is not enough to merely showthat a  system can meet its requirements. A few tests generally suffice  todemonstrate that. The real test is to show that a system cannot fail to  meet itsrequirements. Dijkstra's well-known dictum on testing1 applies  especially to concurrentsoftware: the non-determinism of concurrent system executions makes it hardto devise a traditional test suite with sufficient coverage. There are fundamentalproblems here, related to both the limited  controllability of events in distributedsystem executions and to the  limited observability of those events. A well-designed system provably  meets its design requirements. But, if wecannot achieve this degree of  certainty with standard test methods, what elsecan we do? Using standard  mathematics is not much of an option in thisdomain. A thorough hand proof  of even simple distributed programs canchallenge the most hardened  mathematician. At first blush, mechanical proofprocedures also do not seem to hold much promise: it was shown long ago that it is fundamentally  impossible to construct a general proof procedure forarbitrary programs.3  So what gives? 1. The quote ''Program testing can be used to show the  presence of bugs, but never to showtheir absence'' first appeared in  Dijkstra 1972, p. 6. The quote has a curious pendant in Dijkstra1965 that  is rarely mentioned: ''One can never guarantee that a proof is correct,  the bestone can say is: "I have not discovered any mistakes."'' 2. For  instance, process scheduling decisions made simultaneously by different  processors atdistinct locations in a larger network. Fortunately, if some  modest conditions are met, we can mechanically verifythe correctness of  distributed systems software. It is the subject of this bookto show what  these ''modest conditions'' are and how we can use relativelysimple  tool-based verification techniques to tackle demanding software  designproblems. LOGIC MODEL CHECKING The method that we will use to check  the correctness of software designs isstandard in most engineering  disciplines. The method is called model checking.When the software itself  cannot be verified exhaustively, we can build asimplified model of the  underlying design that preserves its essential characteristicsbut that  avoids known sources of complexity. The design model canoften be verified, while the full-scale implementation cannot. Bridge builders and airplane  designers apply much the same technique whenfaced with complex design  problems. By building and analyzing models (orprototypes) the risk of  implementing a subtly flawed design is reduced. It isoften too expensive  to locate or fix design errors once they hav e reached theimplementation  phase. The same is true for the design of complex software.The modeling  techniques that we discuss in this book work especially well forconcurrent software, which, as luck will have it, is also the most difficult todebug  and test with traditional means. The models we will build can be seen as  little programs, written in, what mayat first look like, a strangely  abstract language. The models that are written inthis language are in fact executable. The behaviors they specify can be simulatedand explored  exhaustively by the model checker in the hunt for logicerrors.  Constructing and executing these high-level models can be fun  andinsightful. It often also gives a sufficiently different perspective on a programmingproblem that may lead to new solutions, even before any  precise checks are performed. A logic model checker is designed to use  efficient procedures for characterizingall possible executions, rather  than a small subset, as one might see in trialexecutions. Since it can  explore all behaviors, the model checker can apply arange of sanity checks to the design model, and it can successfully identifyunexecutable code, or potentially deadlocking concurrent executions. It canev en check for  compliance with complex user-defined correctness criteria.Model checkers  are unequalled in their ability to locate subtle bugs in systemdesigns,  providing far greater control than the more traditional methods basedon  human inspection, testing, or random simulation. Model checking techniques have been applied in large scale industrial applications,to reduce the  reliance on testing, to detect design flaws early in adesign cycle, or to  prove their absence in a final design. Some examples ofthese applications  are discussed in this book. THE SPIN MODEL CHECKER The methodology we  describe in this book centers on the use of the modelchecker SPIN. This  verification system was developed at Bell Labs in theeighties and nineties and is freely available from the Web (see Appendix D).The tool continues  to evolve and has over many years attracted a fairly broadgroup of users  in both academia and industry. At the time of writing, SPIN isone of the  most widely used logic model checkers in the world. In 2002 SPIN was  recognized by the ACM (the Association for ComputingMachinery) with its  most prestigious Software System Award. In receivingthis award, SPIN was  placed in the league of truly breakthrough software systemssuch as UNIX,  TeX, Smalltalk, Postscript, TCP/IP, and Tcl/Tk. Theaw ard has brought a  significant amount of additional attention to the tool andits underlying  technology. With all these developments there has been agrowing need for a single authoritative and comprehensive user guide. Thisbook is meant to be that guide. The material in this book can be used either as classroom  material or as aself-study guide for new users who want to learn about the background anduse of logic model checking techniques. A significant part  of the book isdevoted to a comprehensive set of reference materials for  SPIN that combinesinformation that both novice and experienced users can  apply on a daily basis. BOOK STRUCTURE SPIN can be used to thoroughly  check high-level models of concurrent systems.This means that we first  have to explain how one can convenientlymodel the behavior of a concurrent system in such a way that SPIN can checkit. Next, we have to show how to  define correctness properties for the detailedchecks, and how to design  abstraction methods that can be used to renderseemingly complex  verification problems tractable. We do all this in the firstpart of this  book, Chapters 1 to 5. The second part, Chapters 6 to 10, provides a  treatment of the theory behindsoftware model checking, and a detailed  explanation of the fundamental algorithmsthat are used in SPIN. The third  part of the book, Chapters 11 to 15, contains more targeted help ingetting started with the practical application of the tool. In this part of  thebook we discuss the command line interface to SPIN, the graphical user  interfaceXSPIN, and also a closely related graphical tool that can be used for anintuitive specification of correctness properties, the Timeline  editor. This partis concluded with a discussion of the application of SPIN to a range of standardproblems in distributed systems design. Chapters 16  to 19, the fourth and last part of the book, include a complete setof  reference materials for SPIN and its input language, information that was  sofar only available in scattered form in books, tutorials, papers, and  Web pages.This part contains a full set of manual pages for every language construct andev ery tool option available in the most recent versions of  SPIN and XSPIN.The Web site http://spinroot.com/spin/Doc/Book\_extras/  contains online versions of all examples used in this book, some lecture  materials, and an up to date list of errata. For courses in model checking techniques, the material included here can provideboth a thorough  understanding of the theory of logic model checking andhands-on training  with the practical application of a well-known model checkingsystem. For a more targeted use that is focused directly on the practicalapplication of  SPIN, the more foundational part of the book can be skipped.A first  version of this text was used for several courses in formal  verificationtechniques that I taught at Princeton University in New  Jersey, at ColumbiaUniversity in New York, and at the Royal Institute of  Technology in Stockholm,Sweden, in the early nineties. I am most grateful  to everyone who gavefeedback, caught errors, and made suggestions for  improvements, as well as toall dedicated SPIN users who have graciously  done this throughout the years,and who fortunately continue to do so. I  especially would like to thank Dragan Bosnacki, from Eindhoven  Universityin The Netherlands, who read multiple drafts for this book with  an unusuallykeen eye for spotting inconsistencies, and intercepting flaws. I would alsolike to thank Al Aho, Rajeev Alur, Jon Bentley, Ramesh  Bharadwaj, EdBrinksma, Marsha Chechik, Costas Courcoubetis, Dennis Dams,  Matt Dwyer,Vic Du, Kousha Etessami, Michael Ferguson, Rob Gerth, Patrice  Godefroid,Jan Hajek, John Hatcliff, Klaus Havelund, Leszek Holenderski,  BrianKernighan, Orna Kupferman, Bob Kurshan, Pedro Merino, Alice Miller,  DougMcIlroy, Anna Beate Oestreicher, Doron Peled, Rob Pike, Amir Pnueli,  AnujPuri, Norman Ramsey, Jim Reeds, Dennis Ritchie, Willem-Paul de  Roever,Judi Romijn, Theo Ruys, Ravi Sethi, Margaret Smith, Heikki  Tauriainen, KenThompson, Howard Trickey, Moshe Vardi, Phil Winterbottom,  Pierre Wolper,Mihalis Yannakakis, and Ozan Yigit, for their often profound influence thathelped to shape the tool, and this book. Gerard J. Holzmann  gholzmann@acm.org  }},
    author = {Holzmann, Gerard J.},
    citeulike-article-id = {689167},
    citeulike-linkout-0 = {http://www.amazon.ca/exec/obidos/redirect?tag=citeulike09-20\&amp;path=ASIN/0321228626},
    citeulike-linkout-1 = {http://www.amazon.de/exec/obidos/redirect?tag=citeulike01-21\&amp;path=ASIN/0321228626},
    citeulike-linkout-2 = {http://www.amazon.fr/exec/obidos/redirect?tag=citeulike06-21\&amp;path=ASIN/0321228626},
    citeulike-linkout-3 = {http://www.amazon.jp/exec/obidos/ASIN/0321228626},
    citeulike-linkout-4 = {http://www.amazon.co.uk/exec/obidos/ASIN/0321228626/citeulike00-21},
    citeulike-linkout-5 = {http://www.amazon.com/exec/obidos/redirect?tag=citeulike07-20\&path=ASIN/0321228626},
    citeulike-linkout-6 = {http://www.worldcat.org/isbn/0321228626},
    citeulike-linkout-7 = {http://books.google.com/books?vid=ISBN0321228626},
    citeulike-linkout-8 = {http://www.amazon.com/gp/search?keywords=0321228626\&index=books\&linkCode=qs},
    citeulike-linkout-9 = {http://www.librarything.com/isbn/0321228626},
    comment = {book/The\_SPIN\_Model\_Checker.pdf},
    day = {14},
    edition = {1},
    howpublished = {Hardcover},
    isbn = {0321228626},
    keywords = {formal\_methods},
    month = sep,
    posted-at = {2012-04-17 22:59:42},
    priority = {2},
    publisher = {Addison-Wesley Professional},
    title = {{The SPIN Model Checker: Primer and Reference Manual}},
    url = {http://www.worldcat.org/isbn/0321228626},
    year = {2003}
}

@inproceedings{Rabiner1989Tutorial,
    abstract = {{Although initially introduced and studied in the late 1960s and early 1970s, statistical methods of Markov source or hidden Markov modeling have become increasingly popular in the last several years. There are two strong reasons why this has occurred. First the models are very rich in mathematical structure and hence can form the theoretical basis for use in a wide range of applications. Sec-ond the models, when applied properly, work very well in practice for several important applications. In this paper we attempt to care-fully and methodically review the theoretical aspects of this type of statistical modeling and show how they have been applied to selected problems in machine recognition of speech. I.}},
    author = {Rabiner, Lawrence R.},
    booktitle = {Proceedings of the IEEE},
    citeulike-article-id = {4037759},
    citeulike-linkout-0 = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.131.2084},
    keywords = {ai, maths},
    pages = {257--286},
    posted-at = {2012-04-13 22:25:01},
    priority = {0},
    title = {{A tutorial on hidden markov models and selected applications in speech recognition}},
    url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.131.2084},
    volume = {77},
    year = {1989}
}

@inproceedings{Chipounov2008Reverseengineering,
    abstract = {{Device drivers today lack two important properties: guaranteed safety and cross-platform portability. We present an approach to incrementally achieving these properties in drivers, without requiring any changes in the drivers or operating system kernels. We describe RevEng, a tool for automatically reverse-engineering a binary driver and synthesizing a new, safe and portable driver that mimics the original one. The operating system kernel runs the trusted synthetic driver instead of the original, thus avoiding giving untrusted driver code kernel privileges. Initial results are promising: we reverse-engineered the basic functionality of network drivers in Linux and Windows based solely on their binaries, and we synthesized safe drivers for Linux. We hope RevEng will eventually persuade hardware vendors to provide verifiable formal specifications instead of binary drivers; such specifications can be used to automatically synthesize safe drivers for every desired platform.}},
    address = {Berkeley, CA, USA},
    author = {Chipounov, Vitaly and Candea, George},
    booktitle = {Proceedings of the Fourth conference on Hot topics in system dependability},
    citeulike-article-id = {10562909},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=1855557},
    comment = {paper\_depo/10.1.1.145.5379.pdf},
    keywords = {system},
    location = {San Diego, California},
    pages = {1},
    posted-at = {2012-04-13 20:49:04},
    priority = {2},
    publisher = {USENIX Association},
    series = {HotDep'08},
    title = {{Reverse-engineering drivers for safety and portability}},
    url = {http://portal.acm.org/citation.cfm?id=1855557},
    year = {2008}
}

@article{Thomas1995Synthesis,
    abstract = {{. Infinite two-person games are a natural framework for the study of reactive nonterminating programs. The effective construction of winning strategies in such games is an approach to the synthesis of reactive programs. We describe the automata theoretic setting of infinite games (given by "game graphs"), outline a new construction of winning strategies in finite-state games, and formulate some questions which arise for games over effectively presented infinite graphs. 1 Introduction One of the origins of automata theory over infinite strings was the interest in verifying and synthesizing switching circuits. These circuits were considered as transforming infinite input sequences into output sequences, and systems of restricted arithmetic served as specification formalisms ([Ch63]). With Buchi's decision procedure for the monadic second-order theory S1S of one successor ([Bu62]), it turned out that the "solution problem" (in more recent terminology: the verification problem or model ch...}},
    author = {Thomas, Wolfgang},
    citeulike-article-id = {10556292},
    citeulike-linkout-0 = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.31.7780},
    comment = {paper\_depo/10.1.1.31.7780.pdf},
    keywords = {game\_theory},
    posted-at = {2012-04-11 05:18:33},
    priority = {2},
    title = {{On the Synthesis of Strategies in Infinite Games}},
    url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.31.7780},
    year = {1995}
}

@inproceedings{Holzmann1988Algorithms,
    abstract = {{This paper studies the four basic types of algorithm that, over the last ten years, have been  developed for the automated validation of the logical consistency of data communication  protocols. The algorithms are compared on memory usage, CPU time requirements, and  the quality, or coverage, of the search for errors.  It is shown that the best algorithm, according to above criteria, can be improved further in  a significant way, by avoiding a known performance bottleneck. The algorithm derived  in this manner works in a fixed size memory arena (it will never run out of memory), it is  up to two orders of magnitude faster than the previous methods, and it has superior coverage  of the state space when analyzing large protocol systems. The algorithm is the first  for which the search efficiency (the number of states analyzed per second) does not  depend of the size of the state space: there is no time penalty for analyzing very large  state spaces.  The effectiveness of the new algorith...}},
    author = {Holzmann, Gerard J.},
    booktitle = {AT\&T TECHNICAL JOURNAL},
    citeulike-article-id = {10546811},
    citeulike-linkout-0 = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.37.8528},
    comment = {paper\_depo/10.1.1.37.8528.pdf},
    keywords = {formal\_methods},
    pages = {163--188},
    posted-at = {2012-04-09 00:34:54},
    priority = {2},
    title = {{Algorithms for Automated Protocol Validation}},
    url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.37.8528},
    year = {1988}
}

@manual{2007Basic,
    address = {http://spinroot.com/spin/Man/Manual.html},
    booktitle = {http://spinroot.com/spin/Man/Manual.html},
    citeulike-article-id = {10546494},
    citeulike-linkout-0 = {http://spinroot.com/spin/Man/Manual.html},
    comment = {http://spinroot.com/spin/Man/Manual.html},
    day = {3},
    howpublished = {http://spinroot.com/spin/Man/Manual.html},
    institution = {http://spinroot.com/spin/Man/Manual.html},
    journal = {http://spinroot.com/spin/Man/Manual.html},
    keywords = {formal\_methods},
    month = jun,
    posted-at = {2012-04-08 22:11:32},
    priority = {2},
    title = {{Basic Spin Manual}},
    url = {http://spinroot.com/spin/Man/Manual.html},
    year = {2007}
}

@article{Heping1996Fast,
    abstract = {{An abstract is not available.}},
    address = {New York, NY, USA},
    author = {Heping, H. and Zedan, H.},
    citeulike-article-id = {10522636},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=245827},
    citeulike-linkout-1 = {http://dx.doi.org/10.1016/1383-7621(96)00024-0},
    comment = {paper\_depo/1-s2.0-1383762196000240-main.pdf},
    doi = {10.1016/1383-7621(96)00024-0},
    issn = {1383-7621},
    journal = {J. Syst. Archit.},
    keywords = {formal\_methods, software\_engineering},
    month = nov,
    number = {4},
    pages = {251--266},
    posted-at = {2012-04-02 21:26:38},
    priority = {2},
    publisher = {Elsevier North-Holland, Inc.},
    title = {{A fast prototype tool for parallel reactive systems}},
    url = {http://dx.doi.org/10.1016/1383-7621(96)00024-0},
    volume = {42},
    year = {1996}
}

@article{Bynum1996After,
    abstract = {{An abstract is not available.}},
    address = {New York, NY, USA},
    author = {Bynum, Bill and Camp, Tracy},
    citeulike-article-id = {10509035},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=236462.236533},
    citeulike-linkout-1 = {http://dx.doi.org/10.1145/236462.236533},
    comment = {paper\_depo/p170-bynum.pdf},
    doi = {10.1145/236462.236533},
    issn = {0097-8418},
    journal = {SIGCSE Bull.},
    keywords = {software\_engineering},
    month = mar,
    number = {1},
    pages = {170--174},
    posted-at = {2012-03-29 01:41:58},
    priority = {2},
    publisher = {ACM},
    title = {{After you, Alfonse: a mutual exclusion toolkit}},
    url = {http://dx.doi.org/10.1145/236462.236533},
    volume = {28},
    year = {1996}
}

@article{MordechaiMotiBenAri2010Primer,
    abstract = {{Model checking is a widely used formal method for the verification of concurrent programs. This article starts with an introduction to the concepts of model checking, followed by a description of Spin, one of the foremost model checkers. Software tools for teaching concurrency and nondeterminism using model checking are described: Erigone, a model checker for teaching; jSpin, a development environment; VN, a visualization of nondeterminism.}},
    address = {New York, NY, USA},
    author = {Mordechai Moti Ben Ari},
    citeulike-article-id = {10509019},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=1721950},
    citeulike-linkout-1 = {http://dx.doi.org/10.1145/1721933.1721950},
    comment = {paper\_depo/p40-ben-ari.pdf},
    doi = {10.1145/1721933.1721950},
    issn = {2153-2184},
    journal = {ACM Inroads},
    keywords = {formal\_methods},
    month = mar,
    number = {1},
    pages = {40--47},
    posted-at = {2012-03-29 01:39:28},
    priority = {2},
    publisher = {ACM},
    title = {{A primer on model checking}},
    url = {http://dx.doi.org/10.1145/1721933.1721950},
    volume = {1},
    year = {2010}
}

@inproceedings{Bamakhrama2011Hardrealtime,
    abstract = {{Most of the hard-real-time scheduling theory for multiprocessor systems assumes independent periodic or sporadic tasks. Such a simple task model is not directly applicable to modern embedded streaming applications. This is because a modern streaming application is typically modeled as a directed graph where nodes represent actors (i.e. tasks) and edges represent data-dependencies. The actors in such graphs have data-dependency constraints and do not necessarily conform to the periodic or sporadic task models. Therefore, in this paper we investigate the applicability of hard-real-time scheduling theory for periodic tasks to streaming applications modeled as acyclic Cyclo-Static Dataflow (CSDF) graphs. In such graphs, the actors are data-dependent, however, we analytically prove that they (i.e. the actors) can be scheduled as implicit-deadline periodic tasks. As a result, a variety of hard-real-time scheduling algorithms for periodic tasks can be applied to schedule such applications with a certain guaranteed throughput. We compare the throughput resulting from such scheduling approach to the maximum achievable throughput of an application for a set of 19 real streaming applications. We find that in more than 80\% of the cases, the throughput resulting from our approach is equal to the maximum achievable throughput.}},
    address = {New York, NY, USA},
    author = {Bamakhrama, Mohamed and Stefanov, Todor},
    booktitle = {Proceedings of the ninth ACM international conference on Embedded software},
    citeulike-article-id = {10503642},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=2038672},
    citeulike-linkout-1 = {http://dx.doi.org/10.1145/2038642.2038672},
    comment = {paper\_depo/p195-bamakhrama.pdf},
    doi = {10.1145/2038642.2038672},
    isbn = {978-1-4503-0714-7},
    keywords = {system},
    location = {Taipei, Taiwan},
    pages = {195--204},
    posted-at = {2012-03-27 20:09:40},
    priority = {2},
    publisher = {ACM},
    series = {EMSOFT '11},
    title = {{Hard-real-time scheduling of data-dependent tasks in embedded streaming applications}},
    url = {http://dx.doi.org/10.1145/2038642.2038672},
    year = {2011}
}

@article{Killian2007Mace,
    abstract = {{Building distributed systems is particularly difficult because of the asynchronous, heterogeneous, and failure-prone environment where these systemsmust run. Tools for building distributed systems must strike a compromise between reducing programmer effort and increasing system efficiency. We present Mace, a C++ language extension and source-to-source compiler that translates a concise but expressive distributed system specification into a C++ implementation. Mace overcomes the limitations of low-level languages by providing a unified framework for networking and event handling, and the limitations of high-level languages by allowing programmers to write program components in a controlled and structured manner in C++. By imposing structure and restrictions on how applications can be written, Mace supports debugging at a higher level, including support for efficient model checking and causal-path debugging. Because Mace programs compile to C++, programmers can use existing C++ tools, including optimizers, profilers, and debuggers to analyze their systems.}},
    address = {New York, NY, USA},
    author = {Killian, Charles E. and Anderson, James W. and Braud, Ryan and Jhala, Ranjit and Vahdat, Amin M.},
    citeulike-article-id = {1819141},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=1273442.1250755},
    citeulike-linkout-1 = {http://dx.doi.org/10.1145/1273442.1250755},
    comment = {paper\_depo/p179-killian.pdf},
    doi = {10.1145/1273442.1250755},
    isbn = {9781595936332},
    issn = {0362-1340},
    journal = {SIGPLAN Not.},
    month = jun,
    number = {6},
    pages = {179--188},
    posted-at = {2012-03-27 02:12:59},
    priority = {2},
    publisher = {ACM},
    title = {{Mace: language support for building distributed systems}},
    url = {http://dx.doi.org/10.1145/1273442.1250755},
    volume = {42},
    year = {2007}
}

@article{Chen2004Reactive,
    abstract = {{Most fault-tolerant application programs cannot cope with constant changes in their environments and user requirements because they embed policies and mechanisms together so that if the policies or mechanisms are changed the whole programs have to be changed as well. This paper presents a reactive system approach to overcoming this limitation. The reactive system concepts are an attractive paradigm for system design, development and maintenance because they separate policies from mechanisms. In the paper we propose a generic reactive system architecture and use group communication primitives to model it. We then implement it as a generic pack age which can be applied in any distributed applications. The system performance shows that it can be used in a distributed environment effectively.}},
    address = {New York, NY, USA},
    author = {Chen, Changgui and Jia, Weijia and Zhou, Wanlei},
    citeulike-article-id = {10501505},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=1027366},
    citeulike-linkout-1 = {http://dx.doi.org/10.1016/S0164-1212(03)00098-0},
    comment = {paper\_depo/1-s2.0-S0164121203000980-main.pdf},
    doi = {10.1016/S0164-1212(03)00098-0},
    issn = {0164-1212},
    journal = {J. Syst. Softw.},
    keywords = {system},
    month = aug,
    number = {3},
    pages = {401--415},
    posted-at = {2012-03-27 02:00:55},
    priority = {2},
    publisher = {Elsevier Science Inc.},
    title = {{A reactive system architecture for building fault-tolerant distributed applications}},
    url = {http://dx.doi.org/10.1016/S0164-1212(03)00098-0},
    volume = {72},
    year = {2004}
}

@inproceedings{Boasson1996Modeling,
    abstract = {{In currently used paradigms for system development, knowledge about the objects in the system's environment is used to derive algorithms that relate events in the environment to actions. This results in implicit representation of the original knowledge in the operational system. In the majority of cases there are only very limited mechanisms for controlling these built-in behaviors, whereas for powerful decision support it is essential to be able to "experiment" both with various hypotheses of behavior of real-world entities and with possible own actions. Such simulation-like operation necessitates explicit representation of behavioral models. A new paradigm for the development of reactive systems is therefore proposed in which the behavioral models are explicitly represented and the user of the system is given direct control over these models. This will allow the user to easily express both hypotheses about intentions of real-world entities, and potential own actions necessary to meet mission goals. Through control of simulated time, the possible evolutions of the environment can then be studied directly.}},
    address = {Washington, DC, USA},
    author = {Boasson, Maarten},
    booktitle = {Proceedings of the 4th International Workshop on Parallel and Distributed Real-Time Systems},
    citeulike-article-id = {10501498},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=837928},
    comment = {paper\_depo/00557434.pdf},
    isbn = {0-8186-7515-2},
    keywords = {system},
    posted-at = {2012-03-27 01:53:27},
    priority = {2},
    publisher = {IEEE Computer Society},
    series = {WPDRTS '96},
    title = {{Modeling and Simulation in Reactive Systems}},
    url = {http://portal.acm.org/citation.cfm?id=837928},
    year = {1996}
}

@book{Barnes1997High,
    author = {Barnes, John},
    citeulike-article-id = {10501486},
    comment = {I think it can be borrowed from BU library.},
    day = {15},
    edition = {1},
    isbn = {0201175177},
    keywords = {formal\_methods, programming\_language},
    month = jun,
    posted-at = {2012-03-27 01:41:14},
    priority = {2},
    title = {{High Integrity Ada: The Spark Approach}},
    year = {1997}
}

@article{VolpanoSOUND,
    abstract = {{Ensuring secure information ow within programs in the context of multiple sensitivity levels has been widely studied. Especially noteworthy is Denning's work in secure ow analysis and the lattice model [6][7]. Until now, however, the soundness of Denning's analysis has not been established satisfactorily. We formulate Denning's approach as a type system and present a notion of soundness for the system that can be viewed as a form of noninterference. Soundness is established by proving, with respect to a standard programming language semantics, that all well-typed programs have this noninterference property.}},
    author = {Volpano, Dennis and Smith, Geoffrey and Irvine, Cynthia},
    citeulike-article-id = {10491564},
    citeulike-linkout-0 = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.149.5391},
    comment = {paper\_depo/10.1.1.149.5391.pdf},
    keywords = {formal\_methods},
    posted-at = {2012-03-23 18:06:19},
    priority = {2},
    title = {A SOUND TYPE SYSTEM FOR SECURE FLOW ANALYSIS},
    url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.149.5391}
}

@article{Dillon1994Graphical,
    abstract = {{This article describes a graphical interval logic that is the foundation of a tool set supporting formal specification and verification of concurrent software systems. Experience has shown that most software engineers find standard temporal logics difficult to understand and use. The objective of this article is to enable software engineers to specify and reason about temporal properties of concurrent systems more easily by providing them with a logic that has an intuitive graphical representation and with tools that support its use. To illustrate the use of the graphical logic, the article provides some specifications for an elevator system and proves several properties of the specifications. The article also describes the tool set and the implementation.}},
    address = {New York, NY, USA},
    author = {Dillon, L. K. and Kutty, G. and Moser, L. E. and Smith, P. Melliar M. and Ramakrishna, Y. S.},
    citeulike-article-id = {10445373},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=192218.192226},
    citeulike-linkout-1 = {http://dx.doi.org/10.1145/192218.192226},
    comment = {paper\_depo/10.1.1.53.1901.pdf},
    doi = {10.1145/192218.192226},
    issn = {1049-331X},
    journal = {ACM Trans. Softw. Eng. Methodol.},
    keywords = {formal\_methods},
    month = apr,
    number = {2},
    pages = {131--165},
    posted-at = {2012-03-13 02:05:11},
    priority = {2},
    publisher = {ACM},
    title = {{A graphical interval logic for specifying concurrent systems}},
    url = {http://dx.doi.org/10.1145/192218.192226},
    volume = {3},
    year = {1994}
}

@unpublished{Warton2005Single,
    author = {Warton, Matthew},
    citeulike-article-id = {10426105},
    institution = {The University of New South Wales School of Computer Science and Engineering},
    journal = {Bachelor of Engineering Thesis},
    keywords = {system},
    month = nov,
    posted-at = {2012-03-08 01:22:28},
    priority = {2},
    title = {{Single Kernel Stack L4}},
    year = {2005}
}

@book{Russell2009Artificial,
    abstract = {{Presents a guide to artificial intelligence, covering such topics as intelligent agents, problem-solving, logical agents, planning, uncertainty, learning, and robotics.}},
    author = {Russell, Stuart and Norvig, Peter},
    citeulike-article-id = {113848},
    citeulike-linkout-0 = {http://www.amazon.ca/exec/obidos/redirect?tag=citeulike09-20\&amp;path=ASIN/0137903952},
    citeulike-linkout-1 = {http://www.amazon.de/exec/obidos/redirect?tag=citeulike01-21\&amp;path=ASIN/0137903952},
    citeulike-linkout-10 = {http://www.worldcat.org/oclc/51325314},
    citeulike-linkout-2 = {http://www.amazon.fr/exec/obidos/redirect?tag=citeulike06-21\&amp;path=ASIN/0137903952},
    citeulike-linkout-3 = {http://www.amazon.jp/exec/obidos/ASIN/0137903952},
    citeulike-linkout-4 = {http://www.amazon.co.uk/exec/obidos/ASIN/0137903952/citeulike00-21},
    citeulike-linkout-5 = {http://www.amazon.com/exec/obidos/redirect?tag=citeulike07-20\&path=ASIN/0137903952},
    citeulike-linkout-6 = {http://www.worldcat.org/isbn/0137903952},
    citeulike-linkout-7 = {http://books.google.com/books?vid=ISBN0137903952},
    citeulike-linkout-8 = {http://www.amazon.com/gp/search?keywords=0137903952\&index=books\&linkCode=qs},
    citeulike-linkout-9 = {http://www.librarything.com/isbn/0137903952},
    comment = {6. Constraint Satisfaction Problems
7. Logical Agents
8. First-Order Logic
9. Inference in First-Order Logic
10. Classical Planning
11. Planning and Acting in the Real World
12. Knowledge Representation
},
    day = {11},
    edition = {3},
    howpublished = {Hardcover},
    isbn = {0136042597},
    month = dec,
    posted-at = {2012-03-07 00:16:45},
    priority = {2},
    publisher = {Prentice Hall},
    series = {Prentice Hall series in artificial intelligence},
    title = {{Artificial Intelligence: A Modern Approach (3rd Edition)}},
    url = {http://www.worldcat.org/isbn/0137903952},
    year = {2009}
}

@inproceedings{Andrus2011Cells,
    abstract = {{Smartphones are increasingly ubiquitous, and many users carry multiple phones to accommodate work, personal, and geographic mobility needs. We present Cells, a virtualization architecture for enabling multiple virtual smartphones to run simultaneously on the same physical cellphone in an isolated, secure manner. Cells introduces a usage model of having one foreground virtual phone and multiple background virtual phones. This model enables a new device namespace mechanism and novel device proxies that integrate with lightweight operating system virtualization to multiplex phone hardware across multiple virtual phones while providing native hardware device performance. Cells virtual phone features include fully accelerated 3D graphics, complete power, management features, and full telephony functionality with separately assignable telephone numbers and caller ID support. We have implemented a prototype of Cells that supports multiple Android virtual phones on the same phone. Our performance results demonstrate that Cells imposes only modest runtime and memory overhead, works seamlessly across multiple hardware devices including Google Nexus 1 and Nexus S phones, and transparently runs Android applications at native speed without any modifications.}},
    address = {New York, NY, USA},
    author = {Andrus, Jeremy and Dall, Christoffer and Hof, Alexander V. and Laadan, Oren and Nieh, Jason},
    booktitle = {Proceedings of the Twenty-Third ACM Symposium on Operating Systems Principles},
    citeulike-article-id = {9940715},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=2043574},
    citeulike-linkout-1 = {http://dx.doi.org/10.1145/2043556.2043574},
    comment = {paper\_depo/13-andrus.pdf},
    doi = {10.1145/2043556.2043574},
    isbn = {978-1-4503-0977-6},
    keywords = {system},
    location = {Cascais, Portugal},
    pages = {173--187},
    posted-at = {2012-03-07 00:10:08},
    priority = {2},
    publisher = {ACM},
    series = {SOSP '11},
    title = {{Cells: a virtual mobile smartphone architecture}},
    url = {http://dx.doi.org/10.1145/2043556.2043574},
    year = {2011}
}

@inproceedings{BhattModelBased,
    abstract = {{The term "Model based design and development" has grown in popularity over the past decade. Within the embedded avionics community the term model based design implies the development and application of "control models and simulations" within tools such as MATLAB. At Honeywell, the authors have been engaged in model based development (MBD) and associated tools development for avionics applications. This position paper applies the lessons learned and discusses several issues, relating to sound model-based design, to meet design assurance and certification objectives. The paper examines the dominant approaches utilized by some of the popular model-based design, code generation and verification tool suites available commercially. It contrasts these approaches to traditional software design, implementation, and verification methods. This paper also recommends taking a broader perspective of MBD and suggests adopting lessons learned from the classical software engineering arena. We discuss this together with areas for future investigation, standardization, and automation tool development and integration.}},
    author = {Bhatt, D. and Hall, B. and Dajani-Brown, S. and Hickman, S. and Paulitsch, M.},
    citeulike-article-id = {8399247},
    citeulike-linkout-0 = {http://dx.doi.org/10.1109/DASC.2005.1563401},
    citeulike-linkout-1 = {http://ieeexplore.ieee.org/xpls/abs\_all.jsp?arnumber=1563401},
    comment = {paper\_depo/mbddevelopment\_2.pdf},
    doi = {10.1109/DASC.2005.1563401},
    keywords = {formal\_methods},
    location = {Washington, DC, USA},
    pages = {10.D.3-1--10.D.3-13},
    posted-at = {2012-03-04 03:45:43},
    priority = {2},
    title = {{Model-Based Development and the Implications to Design Assurance and Certification}},
    url = {http://dx.doi.org/10.1109/DASC.2005.1563401}
}

@inproceedings{Gamatie2008Modeling,
    abstract = {{This paper presents an approach for the modeling and formalvalidation of high-performance systems. The approach relies on the repetitive model of computation used to express the parallelism of such systems within the Gaspard framework, which is dedicated to the codesign of high-performance system-on-chip. The system descriptions obtained with this model are then projected on the synchronous model of computation. The result of this projectionconsists of an equational model that allows one to formally analyze clock synchronizability issues so as to guarantee the reliable deployment of systems on platforms.}},
    address = {Washington, DC, USA},
    author = {Gamati{\'{e}}, Abdoulaye and Rutten, Eric and Yu, Huafeng and Boulet, Pierre and Dekeyser, Jean L.},
    booktitle = {Proceedings of the 2008 International Symposium on Parallel and Distributed Computing},
    citeulike-article-id = {10412070},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=1493614.1494309},
    citeulike-linkout-1 = {http://dx.doi.org/10.1109/ISPDC.2008.28},
    comment = {paper\_depo/04724249.pdf},
    doi = {10.1109/ISPDC.2008.28},
    isbn = {978-0-7695-3472-5},
    keywords = {formal\_methods, system},
    pages = {215--222},
    posted-at = {2012-03-04 03:43:33},
    priority = {2},
    publisher = {IEEE Computer Society},
    series = {ISPDC '08},
    title = {{Modeling and Formal Validation of High-Performance Embedded Systems}},
    url = {http://dx.doi.org/10.1109/ISPDC.2008.28},
    year = {2008}
}

@article{Gamatie2006Synchronous,
    abstract = {{In this article, we address the design of avionic applications based on an approach, which relies on model refinement. This study is done within the synchronous framework, which has solid mathematical foundations enabling formal methods for specification, verification and analysis, transformations, etc. In the proposed approach, we first consider a functional description of a given application using the SIGNAL language. This description is independent of a specific implementation platform. Then, some transformations that fully preserve the semantics of manipulated SIGNAL programs are applied to the description such that a representation reflecting an integrated modular avionics architecture results.}},
    address = {Amsterdam, The Netherlands, The Netherlands},
    author = {Gamati\'{e}, Abdoulaye and Gautier, Thierry and Le Guernic, Paul},
    citeulike-article-id = {10412069},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=1466505},
    issn = {1740-4460},
    journal = {J. Embedded Comput.},
    keywords = {formal\_methods, system},
    month = dec,
    pages = {273--289},
    posted-at = {2012-03-04 03:40:08},
    priority = {2},
    publisher = {IOS Press},
    title = {{Synchronous design of avionic applications based on model refinement}},
    url = {http://portal.acm.org/citation.cfm?id=1466505},
    volume = {2},
    year = {2006}
}

@book{Manna1991Temporal,
    author = {Manna, Zohar and Pnueli, Amir},
    citeulike-article-id = {10412067},
    day = {18},
    edition = {1},
    isbn = {978-0387976648},
    keywords = {formal\_methods},
    month = dec,
    posted-at = {2012-03-04 03:27:45},
    priority = {2},
    title = {{The Temporal Logic of Reactive and Concurrent Systems: Specification}},
    year = {1991}
}

@inbook{Scholz2003Framework,
    author = {Scholz, Enno},
    chapter = {11.4},
    citeulike-article-id = {10412011},
    comment = {Google Books

Chapter 11.4 talks about several synchronous languages: Lucid, Esteral, and Lustre.},
    keywords = {programming\_language},
    month = jul,
    posted-at = {2012-03-04 02:29:17},
    priority = {2},
    title = {{A Framework for Programming Interactive Graphics in a Functional Programming Language}},
    year = {2003}
}

@misc{RaymondLustre,
    author = {Raymond, Pascal and Halbwachs, Nicolas},
    citeulike-article-id = {10411993},
    comment = {paper\_depo/lustre-a.pdf},
    journal = {Verimag-CNRS},
    keywords = {programming\_language},
    posted-at = {2012-03-04 02:24:18},
    priority = {2},
    title = {{The Lustre Language
Synchronous Programming}}
}

@manual{Pouzet2006Lucid,
    author = {Pouzet, Marc},
    citeulike-article-id = {10411983},
    citeulike-linkout-0 = {http://www.di.ens.fr/\~{}pouzet/lucid-synchrone/manual\_html/index.html},
    comment = {http://www.di.ens.fr/\~{}pouzet/lucid-synchrone/manual\_html/index.html},
    keywords = {programming\_language},
    month = apr,
    posted-at = {2012-03-04 02:15:31},
    priority = {2},
    title = {{Lucid Synchrone Release version 3.0 Tutorial and Reference Manual}},
    url = {http://www.di.ens.fr/\~{}pouzet/lucid-synchrone/manual\_html/index.html},
    year = {2006}
}

@article{Camus2008Verifiable,
    author = {Camus, Jean-Louis and Vincent, Pierre and Graff, Olivier and Poussard, Sebastien},
    citeulike-article-id = {10407335},
    comment = {paper\_depo/ERTS-2008-A-verifiable-architecture-for-multi-task-multi-rate-synchronous.pdf},
    journal = {ERTS 2008},
    posted-at = {2012-03-02 22:50:49},
    priority = {2},
    title = {{A verifiable architecture for multi-task, multi-rate synchronous software}},
    year = {2008}
}

@techreport{Kurihara2009Automotive,
    author = {Kurihara, Masaru},
    citeulike-article-id = {10407330},
    comment = {paper\_depo/Automotive-ECU-software-development-with-SCADE-Suite.pdf
---=note-separator=---
In this article the model-based development environment SCADE Suite is introduced to the existing process for development of a motor control unit in an electric vehicle, with particular reference to safe multi-thread executions.},
    journal = {ECE Magazine},
    month = dec,
    posted-at = {2012-03-02 22:35:29},
    priority = {4},
    title = {{Automotive ECU software development with SCADE Suite}},
    year = {2009}
}

@manual{2011Getting,
    citeulike-article-id = {10406777},
    comment = {paper\_depo/SCADE Suite Getting Started.pdf},
    month = oct,
    posted-at = {2012-03-02 21:57:36},
    priority = {2},
    title = {{Getting Started with SCADE Suite}},
    year = {2011}
}

@manual{2011Getting,
    citeulike-article-id = {10406774},
    comment = {paper\_depo/SCADE Display Getting Started.pdf},
    month = sep,
    posted-at = {2012-03-02 21:55:06},
    priority = {2},
    title = {{Getting Started with SCADE Display}},
    year = {2011}
}

@inproceedings{Datta2011Sorting,
    abstract = {{We introduce a generalization of the distributed sorting problem on chain network. Our problem consists of sorting values in processes that are separated from each other by any number of intermediate processes which can relay values but do not have their own values. We solve this problem in a chain network by proposing a silent self-stabilizing distributed algorithm.}},
    author = {Datta, A. K. and Larmore, L. L. and Devismes, S.},
    booktitle = {Networking and Computing (ICNC), 2011 Second International Conference on},
    citeulike-article-id = {10406645},
    citeulike-linkout-0 = {http://dx.doi.org/10.1109/ICNC.2011.36},
    citeulike-linkout-1 = {http://ieeexplore.ieee.org/xpls/abs\_all.jsp?arnumber=6131806},
    comment = {paper\_depo/06131806.pdf},
    doi = {10.1109/ICNC.2011.36},
    institution = {Sch. of Comput. Sci., UNLV, Las Vegas, NV, USA},
    isbn = {978-1-4577-1796-3},
    keywords = {algorithm},
    month = nov,
    pages = {193--199},
    posted-at = {2012-03-02 19:51:52},
    priority = {2},
    publisher = {IEEE},
    title = {{Sorting on Skip Chains}},
    url = {http://dx.doi.org/10.1109/ICNC.2011.36},
    year = {2011}
}

@inproceedings{Rajan2010GUESSTIMATE,
    abstract = {{We present a new programming model GUEESSTIMATE for developing collaborative distributed systems. The model allows atomic, isolated operations that transform a system from consistent state to consistent state, and provides a shared transactional store for a collection of such operations executed by various machines in a distributed system. In addition to "committed state" which is identical in all machines in the distributed system, GUESSTIMATE allows each machine to have a replicated local copy of the state (called "guesstimated state") so that operations on shared state can be executed locally without any blocking, while also guaranteeing that eventually all machines agree on the sequences of operations executed. Thus, each operation is executed multiple times, once at the time of issue when it updates the guesstimated state of the issuing machine, once when the operation is committed (atomically) to the committed state of all machines, and several times in between as the guesstimated state converges toward the committed state. While we expect the results of these executions of the operation to be identical most of the time in the class of applications we study, it is possible for an operation to succeed the first time when it is executed on the guesstimated state, and fail when it is committed. GUESSTIMATE provides facilities that allow the programmer to deal with this potential discrepancy. This paper presents our programming model, its operational semantics, its realization as an API in C\#, and our experience building collaborative distributed applications with this model.}},
    author = {Rajan, Kaushik and Rajamani, Sriram and Yaduvanshi, Shashank},
    citeulike-article-id = {10398930},
    citeulike-linkout-0 = {http://64.238.147.56/citation.cfm?id=1806621},
    comment = {paper\_depo/pldi083-rajan.pdf},
    editor = {PLDI '10 Proceedings of the 2010 ACM SIGPLAN conference on Programming language design and implementation},
    journal = {PLDI '10 Proceedings of the 2010 ACM SIGPLAN conference on Programming language design and implementation},
    keywords = {formal\_methods, software\_engineering},
    month = jun,
    number = {6},
    posted-at = {2012-02-29 23:38:46},
    priority = {2},
    title = {{GUESSTIMATE: a programming model for collaborative distributed systems}},
    url = {http://64.238.147.56/citation.cfm?id=1806621},
    volume = {45},
    year = {2010}
}

@inproceedings{Emmi2010Parameterized,
    abstract = {{We describe an automatic verification method to check whether transactional memories ensure strict serializability a key property assumed of the transactional interface. Our main contribution is a technique for effectively verifying parameterized systems. The technique merges ideas from parameterized hardware and protocol verification--verification by invisible invariants and symmetry reduction--with ideas from software verification--template-based invariant generation and satisfiability checking for quantified formul{\ae} (modulo theories). The combination enables us to precisely model and analyze unbounded systems while taming state explosion. Our technique enables automated proofs that two-phase locking (TPL), dynamic software transactional memory (DSTM), and transactional locking II (TL2) systems ensure strict serializability. The verification is challenging since the systems are unbounded in several dimensions: the number and length of concurrently executing transactions, and the size of the shared memory they access, have no finite limit. In contrast, state-of-the-art software model checking tools such as BLAST and TVLA are unable to validate either system, due to inherent expressiveness limitations or state explosion.}},
    address = {New York, NY, USA},
    author = {Emmi, Michael and Majumdar, Rupak and Manevich, Roman},
    booktitle = {Proceedings of the 2010 ACM SIGPLAN conference on Programming language design and implementation},
    citeulike-article-id = {10398925},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=1809028.1806613},
    citeulike-linkout-1 = {http://dx.doi.org/10.1145/1806596.1806613},
    comment = {paper\_depo/p134-emmi.pdf},
    doi = {10.1145/1806596.1806613},
    isbn = {978-1-4503-0019-3},
    keywords = {formal\_methods, verification},
    location = {Toronto, Ontario, Canada},
    pages = {134--145},
    posted-at = {2012-02-29 23:31:40},
    priority = {2},
    publisher = {ACM},
    series = {PLDI '10},
    title = {{Parameterized verification of transactional memories}},
    url = {http://dx.doi.org/10.1145/1806596.1806613},
    year = {2010}
}

@article{Yang2010Safe,
    abstract = {{Typed assembly language (TAL) and Hoare logic can verify the absence of many kinds of errors in low-level code. We use TAL and Hoare logic to achieve highly automated, static verification of the safety of a new operating system called Verve. Our techniques and tools mechanically verify the safety of every assembly language instruction in the operating system, run-time system, drivers, and applications (in fact, every part of the system software except the boot loader). Verve consists of a "Nucleus" that provides primitive access to hardware and memory, a kernel that builds services on top of the Nucleus, and applications that run on top of the kernel. The Nucleus, written in verified assembly language, implements allocation, garbage collection, multiple stacks, interrupt handling, and device access. The kernel, written in C\# and compiled to TAL, builds higher-level services, such as preemptive threads, on top of the Nucleus. A TAL checker verifies the safety of the kernel and applications. A Hoare-style verifier with an automated theorem prover verifies both the safety and correctness of the Nucleus. Verve is, to the best of our knowledge, the first operating system mechanically verified to guarantee both type and memory safety. More generally, Verve's approach demonstrates a practical way to mix high-level typed code with low-level untyped code in a verifiably safe manner.}},
    address = {New York, NY, USA},
    author = {Yang, Jean and Hawblitzel, Chris},
    citeulike-article-id = {10398920},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=1806610},
    citeulike-linkout-1 = {http://dx.doi.org/10.1145/1809028.1806610},
    comment = {paper\_depo/p99-yang.pdf},
    doi = {10.1145/1809028.1806610},
    issn = {0362-1340},
    journal = {SIGPLAN Not.},
    keywords = {formal\_methods, operating\_system},
    month = jun,
    pages = {99--110},
    posted-at = {2012-02-29 23:29:14},
    priority = {4},
    publisher = {ACM},
    title = {{Safe to the last instruction: automated verification of a type-safe operating system}},
    url = {http://dx.doi.org/10.1145/1809028.1806610},
    volume = {45},
    year = {2010}
}

@article{Lano2007Direct,
    abstract = {{In this paper we present semantic profiles for UML 2 state machines, which are based directly upon the structure of a state machine model, without requiring flattening or other transformations on these models. The approach addresses many of the semantic problems identified for state machines, and provides a basis for semantic analysis and proof of behavioural compatibility between state machines. 1}},
    author = {Lano, K. and Clark, D.},
    citeulike-article-id = {10398601},
    citeulike-linkout-0 = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.105.8452},
    comment = {paper\_depo/10.1.1.105.8452.pdf},
    keywords = {software\_engineering},
    posted-at = {2012-02-29 21:20:27},
    priority = {2},
    title = {{Direct Semantics of Extended State Machines}},
    url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.105.8452},
    year = {2007}
}

@inproceedings{Holzmann1998Designing,
    abstract = {{An abstract is not available.}},
    address = {New York, NY, USA},
    author = {Holzmann, Gerard J.},
    booktitle = {Proceedings of the second workshop on Formal methods in software practice},
    citeulike-article-id = {10398585},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=298864},
    citeulike-linkout-1 = {http://dx.doi.org/10.1145/298595.298864},
    comment = {paper\_depo/p103-holzmann.pdf},
    doi = {10.1145/298595.298864},
    isbn = {0-89791-954-8},
    keywords = {formal\_methods, software\_engineering},
    location = {Clearwater Beach, Florida, United States},
    pages = {103--108},
    posted-at = {2012-02-29 21:11:02},
    priority = {2},
    publisher = {ACM},
    series = {FMSP '98},
    title = {{Designing executable abstractions}},
    url = {http://dx.doi.org/10.1145/298595.298864},
    year = {1998}
}

@article{Holzmann1997Model,
    abstract = {{SPIN is an efficient verification system for models of distributed software systems. It has been used to detect design errors in applications ranging from high-level descriptions of distributed algorithms to detailed code for controlling telephone exchanges. The paper gives an overview of the design and structure of the verifier, reviews its theoretical foundation, and gives an overview of significant practical applications}},
    address = {Piscataway, NJ, USA},
    author = {Holzmann, G. J.},
    citeulike-article-id = {4190769},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=260902},
    citeulike-linkout-1 = {http://dx.doi.org/10.1109/32.588521},
    citeulike-linkout-2 = {http://ieeexplore.ieee.org/xpls/abs\_all.jsp?arnumber=588521},
    comment = {paper\_depo/00588521.pdf},
    doi = {10.1109/32.588521},
    issn = {00985589},
    journal = {IEEE Transactions on Software Engineering},
    keywords = {formal\_methods, software\_engineering},
    month = may,
    number = {5},
    pages = {279--295},
    posted-at = {2012-02-29 21:03:21},
    priority = {2},
    publisher = {IEEE Press},
    title = {{The model checker SPIN}},
    url = {http://dx.doi.org/10.1109/32.588521},
    volume = {23},
    year = {1997}
}

@inproceedings{Dwyer1998Property,
    abstract = {{An abstract is not available.}},
    address = {New York, NY, USA},
    author = {Dwyer, Matthew B. and Avrunin, George S. and Corbett, James C.},
    booktitle = {Proceedings of the second workshop on Formal methods in software practice},
    citeulike-article-id = {8595463},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=298598},
    citeulike-linkout-1 = {http://dx.doi.org/10.1145/298595.298598},
    comment = {paper\_depo/p7-dwyer.pdf},
    doi = {10.1145/298595.298598},
    isbn = {0-89791-954-8},
    keywords = {formal\_methods, software\_engineering},
    location = {Clearwater Beach, Florida, United States},
    pages = {7--15},
    posted-at = {2012-02-29 21:00:35},
    priority = {0},
    publisher = {ACM},
    series = {FMSP '98},
    title = {{Property specification patterns for finite-state verification}},
    url = {http://dx.doi.org/10.1145/298595.298598},
    year = {1998}
}

@article{Liu1992What,
    abstract = {{An abstract is not available.}},
    address = {New York, NY, USA},
    author = {Liu, Chamond and Goetze, Stephen and Glynn, Bill},
    citeulike-article-id = {10395600},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=141937.141944},
    citeulike-linkout-1 = {http://dx.doi.org/10.1145/141937.141944},
    comment = {paper\_depo/p77-liu.pdf},
    doi = {10.1145/141937.141944},
    issn = {0362-1340},
    journal = {SIGPLAN Not.},
    keywords = {programming\_language},
    month = oct,
    pages = {77--86},
    posted-at = {2012-02-29 03:28:00},
    priority = {2},
    publisher = {ACM},
    title = {{What contributes to successful object-oriented learning?}},
    url = {http://dx.doi.org/10.1145/141937.141944},
    volume = {27},
    year = {1992}
}

@inproceedings{Shi2010Modality,
    abstract = {{The potential of linear logic in facilitating reasoning on resource usage has long been recognized. However, convincing uses of linear types in practical programming are still rather rare. In this paper, we present a general design to effectively support practical programming with linear types. In particular, we introduce and then formalize a modality, which we refer to as the sharing modality, in support of sharing of linear resources (with no use of locks). We develop the underlying type theory for the sharing modality and establish its soundness based on a notion of types with effects. We also point out an intimate relation between this modality and the issue of code reentrancy. In addition, we present realistic examples to illustrate the use of sharing modality, which are verified in the programming language ATS and thus provide a solid proof of concept.}},
    address = {Berlin, Heidelberg},
    author = {Shi, Rui and Zhu, Dengping and Xi, Hongwei},
    booktitle = {Proceedings of the 7th International colloquium conference on Theoretical aspects of computing},
    citeulike-article-id = {10388722},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=1881866},
    comment = {paper\_depo/ictac10.pdf},
    isbn = {3-642-14807-7, 978-3-642-14807-1},
    keywords = {logic, programming\_language, research\_progress},
    location = {Natal, Rio Grande do Norte, Brazil},
    pages = {382--396},
    posted-at = {2012-02-27 03:59:07},
    priority = {4},
    publisher = {Springer-Verlag},
    series = {ICTAC'10},
    title = {{A modality for safe resource sharing and code reentrancy}},
    url = {http://portal.acm.org/citation.cfm?id=1881866},
    year = {2010}
}

@inproceedings{Halbwachs2005Synchronous,
    abstract = {{We recall the story of the development of the synchronous data-flow language Lustre and of its industrial transfer inside the toolset SCADE. We try to analyse the reasons of its success, and to report the main lessons we got from the transfer of an academic concept into real industrial world.}},
    address = {Washington, DC, USA},
    author = {Halbwachs, Nicolas},
    booktitle = {Proceedings of the 2nd ACM/IEEE International Conference on Formal Methods and Models for Co-Design},
    citeulike-article-id = {10388718},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=1322140},
    citeulike-linkout-1 = {http://dx.doi.org/10.1109/MEMCOD.2005.1487884},
    comment = {paper\_depo/halbwachs.memocodes.pdf},
    doi = {10.1109/MEMCOD.2005.1487884},
    isbn = {0-7803-9227-2},
    keywords = {programming\_language, research\_progress},
    pages = {3--11},
    posted-at = {2012-02-27 03:54:27},
    priority = {0},
    publisher = {IEEE Computer Society},
    series = {MEMOCODE '05},
    title = {{A Synchronous Language at Work: the Story of Lustre}},
    url = {http://dx.doi.org/10.1109/MEMCOD.2005.1487884},
    year = {2005}
}

@article{Johnston2004Advances,
    abstract = {{Many developments have taken place within dataflow programming languages in the past decade. In particular, there has been a great deal of activity and advancement in the field of dataflow visual programming languages. The motivation for this article is to review the content of these recent developments and how they came about. It is supported by an initial review of dataflow programming in the 1970s and 1980s that led to current topics of research. It then discusses how dataflow programming evolved toward a hybrid von Neumann dataflow formulation, and adopted a more coarse-grained approach. Recent trends toward dataflow visual programming languages are then discussed with reference to key graphical dataflow languages and their development environments. Finally, the article details four key open topics in dataflow programming languages.}},
    address = {New York, NY, USA},
    author = {Johnston, Wesley M. and Hanna, J. R. Paul and Millar, Richard J.},
    citeulike-article-id = {86951},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=1013208.1013209},
    citeulike-linkout-1 = {http://dx.doi.org/10.1145/1013208.1013209},
    doi = {10.1145/1013208.1013209},
    issn = {0360-0300},
    journal = {ACM Comput. Surv.},
    keywords = {programming\_language, research\_progress},
    month = mar,
    number = {1},
    pages = {1--34},
    posted-at = {2012-02-27 03:52:41},
    priority = {3},
    publisher = {ACM},
    title = {{Advances in dataflow programming languages}},
    url = {http://dx.doi.org/10.1145/1013208.1013209},
    volume = {36},
    year = {2004}
}

@incollection{Uustalu2006Essence,
    abstract = {{We propose a novel, comonadic approach to dataflow (stream-based) computation. This is based on the observation that both general and causal stream functions can be characterized as coKleisli arrows of comonads and on the intuition that comonads in general must be a good means to structure context-dependent computation. In particular, we develop a generic comonadic interpreter of languages for context-dependent computation and instantiate it for stream-based computation. We also discuss distributive laws of a comonad over a monad as a means to structure combinations of effectful and context-dependent computation. We apply the latter to analyse clocked dataflow (partial stream based) computation.}},
    author = {Uustalu, Tarmo and Vene, Varmo},
    citeulike-article-id = {4178611},
    citeulike-linkout-0 = {http://dx.doi.org/10.1007/11894100\_5},
    citeulike-linkout-1 = {http://www.springerlink.com/content/115671u3274468lj},
    doi = {10.1007/11894100\_5},
    journal = {Central European Functional Programming School},
    keywords = {programming\_language, research\_progress},
    pages = {135--167},
    posted-at = {2012-02-27 03:51:41},
    priority = {3},
    title = {{The Essence of Dataflow Programming}},
    url = {http://dx.doi.org/10.1007/11894100\_5},
    year = {2006}
}

@article{Halbwachs1991Synchronous,
    abstract = {{This paper describes the language Lustre, which is a dataflow synchronous language, designed for programming reactive systems --- such as automatic control and monitoring systems --- as well as for describing hardware. The dataflow aspect of Lustre makes it very close to usual description tools in these domains (block-diagrams, networks of operators, dynamical samples-systems, etc: : : ), and its synchronous interpretation makes it well suited for handling time in programs. Moreover, this...}},
    author = {Halbwachs, N. and Caspi, P. and Raymond, P. and Pilaud, D.},
    citeulike-article-id = {349932},
    citeulike-linkout-0 = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.34.5059},
    comment = {paper\_depo/10.1.1.34.5059.pdf

The version I have has actually 40 pages.},
    journal = {Proceedings of the IEEE},
    keywords = {programming\_language, research\_progress},
    month = sep,
    number = {9},
    pages = {1305--1320},
    posted-at = {2012-02-27 03:48:52},
    priority = {3},
    title = {{The synchronous data-flow programming language LUSTRE}},
    url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.34.5059},
    volume = {79},
    year = {1991}
}

@inproceedings{Prabhakaran2005Analysis,
    abstract = {{We develop and apply two new methods for analyzing file system behavior and evaluating file system changes. First, semantic block-level analysis (SBA) combines knowledge of on-disk data structures with a trace of disk traffic to infer file system behavior; in contrast to standard benchmarking approaches, SBA enables users to understand why the file system behaves as it does. Second, semantic trace playback (STP) enables traces of disk traffic to be easily modified to represent changes in the file system implementation; in contrast to directly modifying the file system, STP enables users to rapidly gauge the benefits of new policies. We use SBA to analyze Linux ext3, ReiserFS, JFS, and Windows NTFS; in the process, we uncover many strengths and weaknesses of these journaling file systems. We also apply STP to evaluate several modifications to ext3, demonstrating the benefits of various optimizations without incurring the costs of a real implementation.}},
    address = {Berkeley, CA, USA},
    author = {Prabhakaran, Vijayan and Arpaci Dusseau, Andrea C. and Arpaci Dusseau, Remzi H.},
    booktitle = {Proceedings of the annual conference on USENIX Annual Technical Conference},
    citeulike-article-id = {10388702},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=1247360.1247368},
    keywords = {file\_system, research\_progress},
    location = {Anaheim, CA},
    pages = {8},
    posted-at = {2012-02-27 03:41:40},
    priority = {3},
    publisher = {USENIX Association},
    series = {ATEC '05},
    title = {{Analysis and evolution of journaling file systems}},
    url = {http://portal.acm.org/citation.cfm?id=1247360.1247368},
    year = {2005}
}

@inproceedings{Sun2005HAIL,
    abstract = {{It is difficult to write device drivers. One factor is that writing low-level code for accessing devices and manipulating their registers is tedious and error-prone. For many system-on-chip based systems, buggy hardware, imprecise documentation, and code reuse worsen the situation further. This paper presents HAIL (Hardware Access Interface Language), a language-based approach to simplify device access programming and generate error checking code against bugs in software, hardware, and documentation. HAIL is a domain-specific language that specifies all aspects of a device's programming interface and the access methods in a particular system and OS. A compiler automatically checks the specification and translates it into C code for device access, with optional debugging code. The generated code can be included directly into device driver code. In the paper, we argue that HAIL lowers development effort, incurs minimal runtime overhead, and reduces device access related bugs. We also show that the HAIL specification can be reused for different operating systems, thereby reducing porting costs.}},
    address = {New York, NY, USA},
    author = {Sun, Jun and Yuan, Wanghong and Kallahalla, Mahesh and Islam, Nayeem},
    booktitle = {Proceedings of the 5th ACM international conference on Embedded software},
    citeulike-article-id = {10388701},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=1086230},
    citeulike-linkout-1 = {http://dx.doi.org/10.1145/1086228.1086230},
    doi = {10.1145/1086228.1086230},
    isbn = {1-59593-091-4},
    keywords = {device\_driver, programming\_language, research\_progress},
    location = {Jersey City, NJ, USA},
    pages = {1--9},
    posted-at = {2012-02-27 03:39:25},
    priority = {5},
    publisher = {ACM},
    series = {EMSOFT '05},
    title = {{HAIL: a language for easy and correct device access}},
    url = {http://dx.doi.org/10.1145/1086228.1086230},
    year = {2005}
}

@techreport{SousaFormal,
    author = {Sousa, R. M. and Putnik, G. D.},
    citeulike-article-id = {10388691},
    institution = {University of Minho},
    keywords = {research\_progress},
    posted-at = {2012-02-27 03:32:00},
    priority = {4},
    school = {School of Engineering},
    title = {{Formal Description Technique SDL for manufacturing systems specification and description}}
}

@inproceedings{Ryzhyk2009Automatic,
    abstract = {{Faulty device drivers cause significant damage through down time and data loss. The problem can be mitigated by an improved driver development process that guarantees correctness by construction. We achieve this by synthesising drivers automatically from formal specifications of device interfaces, thus reducing the impact of human error on driver reliability and potentially cutting down on development costs. We present a concrete driver synthesis approach and tool called Termite. We discuss the methodology, the technical and practical limitations of driver synthesis, and provide an evaluation of non-trivial drivers for Linux, generated using our tool. We show that the performance of the generated drivers is on par with the equivalent manually developed drivers. Furthermore, we demonstrate that device specifications can be reused across different operating systems by generating a driver for FreeBSD from the same specification as used for Linux.}},
    address = {New York, NY, USA},
    author = {Ryzhyk, Leonid and Chubb, Peter and Kuz, Ihor and Le Sueur, Etienne and Heiser, Gernot},
    booktitle = {Proceedings of the ACM SIGOPS 22nd symposium on Operating systems principles},
    citeulike-article-id = {10388685},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=1629583},
    citeulike-linkout-1 = {http://dx.doi.org/10.1145/1629575.1629583},
    comment = {paper\_depo/10.1.1.163.3940.pdf},
    doi = {10.1145/1629575.1629583},
    isbn = {978-1-60558-752-3},
    keywords = {device\_driver, research\_progress, software\_engineering, specification},
    location = {Big Sky, Montana, USA},
    pages = {73--86},
    posted-at = {2012-02-27 03:21:26},
    priority = {0},
    publisher = {ACM},
    series = {SOSP '09},
    title = {{Automatic device driver synthesis with termite}},
    url = {http://dx.doi.org/10.1145/1629575.1629583},
    year = {2009}
}

@inbook{Silberschatz2011Database,
    author = {Silberschatz, Abraham and Korth, Henry F. and Sudarshan, S.},
    chapter = {14, 16},
    citeulike-article-id = {10388284},
    comment = {book/[Database.System.Concepts(6th.Edition.2010)].Abraham.Silberschatz.文字版.pdf},
    edition = {6th},
    keywords = {database, research\_progress},
    posted-at = {2012-02-27 00:30:51},
    priority = {0},
    title = {{Database System Concept}},
    year = {2011}
}

@article{Garavel1993Experiment,
    abstract = {{This paper presents the main results of a two-year study concerning the introduction of  formal methods in the life cycle of avionics software. This study was done in the framework  of the EUREKA European project AIMS (Aerospace Intelligent Management and development  environment for embedded Systems).  The ISO language Lotos was used to describe a significant subset of the Flight Warning  Computer of Airbus 330/340 aircrafts, which is a typical representative of Embedded Computer  Systems. Six Lotos descriptions were developed, (using both the abstract data types and the  process algebra features of Lotos) which are probably among the largest algebraic specifications  written today. The Caesar/Ald' ebaran toolset for Lotos was used to support the description  and analysis process. The Lotos descriptions were automatically translated into executable  prototypes, and then validated by means of simulation and testing. The paper presents the  techniques used and the results obtained. It e...}},
    author = {Garavel, Hubert and Hautbois, Ren\'{e}-Pierre},
    citeulike-article-id = {10384036},
    citeulike-linkout-0 = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.47.2495},
    comment = {paper\_depo/10.1.1.47.2495.pdf},
    keywords = {research\_progress},
    posted-at = {2012-02-24 23:25:43},
    priority = {2},
    title = {{An Experiment with the LOTOS Formal Description Technique on the Flight Warning Computer of Airbus 330/340 Aircrafts}},
    url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.47.2495},
    year = {1993}
}

@inproceedings{Harter2011File,
    author = {Harter, Tyler and Dragga, Chris and Vaughn, Michael and Arpaci-Dusseau, Andrea C. and Arpaci-Dusseau, Remzi H.},
    citeulike-article-id = {10384014},
    comment = {paper\_depo/06-harter.pdf},
    day = {23-26},
    institution = {University of Wisconsin, Madison},
    journal = {SOSP},
    keywords = {system},
    month = oct,
    posted-at = {2012-02-24 23:04:16},
    priority = {2},
    title = {{A File is Not a File: Understanding the I/O Behavior of Apple Desktop Applications}},
    year = {2011}
}

@article{Engler2000Checking,
    abstract = {{CiteSeerX - Document Details (Isaac Councill, Lee Giles):}},
    author = {Engler, Dawson and Chelf, Benjamin and Chou, Andy},
    citeulike-article-id = {10384007},
    citeulike-linkout-0 = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.114.3285},
    comment = {paper\_depo/10.1.1.114.3285.pdf},
    keywords = {formal\_methods, programming\_language, research\_progress},
    pages = {1--16},
    posted-at = {2012-02-24 22:56:00},
    priority = {0},
    title = {{Checking system rules using system-specific, programmer-written compiler extensions}},
    url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.114.3285},
    year = {2000}
}

@inproceedings{HalemSystLangSys-specStat02,
    abstract = {{This paper presents a novel approach to bug-finding analysis and an implementation of that approach. Our goal is to find as many serious bugs as possible. To do so, we designed a flexible, easy-to-use extension language for specifying analyses and an efficent algorithm for executing these extensions. The language,  metal , allows the users of our system to specify a broad class of analyses in terms that resemble the intuitive description of the rules that they check. The system,  xgcc , executes these analyses efficiently using a context-sensitive, interprocedural analysis. Our prior work has shown that the approach described in this paper is effective: it has successfully found thousands of bugs in real systems code. This paper describes the underlying system used to achieve these results. We believe that our system is an effective framework for deploying new bug-finding analyses quickly and easily.}},
    address = {New York, NY, USA},
    author = {Hallem, Seth and Chelf, Benjamin and Xie, Yichen and Engler, Dawson},
    booktitle = {PLDI '02: Proceedings of the ACM SIGPLAN 2002 Conference on Programming language design and implementation},
    citeulike-article-id = {841801},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=512539},
    citeulike-linkout-1 = {http://dx.doi.org/10.1145/512529.512539},
    comment = {paper\_depo/p69-hallem.pdf},
    doi = {10.1145/512529.512539},
    isbn = {1-58113-463-0},
    keywords = {formal\_methods, programming\_language, research\_progress},
    location = {Berlin, Germany},
    pages = {69--82},
    posted-at = {2012-02-24 22:29:09},
    priority = {2},
    publisher = {ACM},
    title = {{A system and language for building system-specific, static analyses}},
    url = {http://dx.doi.org/10.1145/512529.512539},
    year = {2002}
}

@article{Holzmann1999Software,
    abstract = {{: To formally verify a large software application, the standard method is to invest a considerable amount of time and expertise into the manual construction of an abstract model, which is then analyzed for its properties by either a mechanized or by a human prover. There are two main problems with this approach. The first problem is that this verification method can be no more reliable than the humans that perform the manual steps. If rate of error for human work is a function of problem size, this holds not only for the construction of the original application, but also for the construction of the model. This means that the verification process tends to become unreliable for larger applications. The second problem is one of timing and relevance. Software applications built by teams of programmers can change rapidly, often daily. Manually constructing a faithful abstraction of any one version of the application, though, can take weeks or months. The results of a verification, then, can...}},
    author = {Holzmann, Gerard J. and Smith, Margaret H.},
    citeulike-article-id = {10383866},
    citeulike-linkout-0 = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.23.997},
    comment = {paper\_depo/10.1.1.23.997.pdf},
    keywords = {formal\_methods, research\_progress},
    posted-at = {2012-02-24 21:50:38},
    priority = {0},
    title = {{Software Model Checking - Extracting Verification Models from Source Code}},
    url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.23.997},
    year = {1999}
}

@inproceedings{Blackham_SCRH_11,
    abstract = {{Operating systems offering virtual memory and protected address spaces have been an elusive target of static worst-case execution time (WCET) analysis. This is due to a combination of size, unstructured code and tight coupling with hardware. As a result, hard real-time systems are usually developed without memory protection, perhaps utilizing a lightweight real-time executive to provide OS abstractions.

This paper presents a WCET analysis of seL4, a third-generation microkernel. seL4 is the world's first formally-verified operating-system kernel, featuring machine-checked correctness proofs of its complete functionality. This makes seL4 an ideal platform for security-critical systems. Adding temporal guarantees makes seL4 also a compelling platform for safety- and timing-critical systems. It creates a foundation for integrating hard real-time systems with less critical time-sharing components on the same processor, supporting enhanced functionality while keeping hardware and development costs low.

We believe this is one of the largest code bases on which a fully context-aware WCET analysis has been performed. This analysis is made possible due to the minimalistic nature of modern microkernels, and properties of seL4's source code arising from the requirements of formal verification.}},
    address = {Vienna, Austria},
    author = {Blackham, Bernard and Shi, Yao and Chattopadhyay, Sudipta and Roychoudhury, Abhik and Heiser, Gernot},
    booktitle = {Proceedings of the 32nd IEEE Real-Time Systems Symposium},
    citeulike-article-id = {10381402},
    comment = {paper\_depo/Blackham\_SCRH\_11.pdf},
    keywords = {operating\_system},
    posted-at = {2012-02-23 23:52:37},
    priority = {0},
    title = {{Timing Analysis of a Protected Operating System Kernel}},
    year = {2011}
}

@electronic{Caspi1995Functional,
    abstract = {{Lustre is a data-flow programming language for reactive purposes, which has been given a synchronous operational semantic. Static checks called "clock calculus " restrict Lustre programs to those data-flow networks which can be executed synchronously. As a by-product of this restriction, Lustre programs enjoy efficient compiling techniques. Yet, due to its reactive origin, Lustre applies only to static networks. We show here, that both this operational semantic, and clock calculus can be extended toward accounting for general functional features: abstraction, application and recursion. This allows us to give sense to both higher order, and dynamical synchronous data-flow networks, which can thus be expected to share the same efficient compiling techniques. 1.}},
    author = {Caspi, Paul and Pouzet, Marc},
    citeulike-article-id = {3139359},
    citeulike-linkout-0 = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.24.429},
    comment = {paper\_depo/10.1.1.24.429\_functional\_extension\_to\_lustre.pdf},
    keywords = {programming\_language, research\_progress},
    month = may,
    posted-at = {2012-01-23 20:50:36},
    priority = {3},
    title = {{A Functional Extension to Lustre}},
    url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.24.429},
    year = {1995}
}

@book{Thompson1991Type,
    author = {Thompson, Simon},
    citeulike-article-id = {10257715},
    comment = {book/ttfp\_type\_theory\_functional\_programming.pdf
},
    keywords = {programming\_language, type\_theory},
    posted-at = {2012-01-23 20:25:47},
    priority = {4},
    title = {{Type Theory and Functional Programming}},
    year = {1991}
}

@manual{Halbwachs2002Tutorial,
    author = {Halbwachs, Nicolas and Raymond, Pascal},
    citeulike-article-id = {10175221},
    comment = {paper\_depo/10.1.1.25.872.pdf
},
    day = {24},
    keywords = {programming\_language, research\_progress},
    month = jan,
    posted-at = {2011-12-28 05:21:28},
    priority = {0},
    title = {{A Tutorial of Lustre}},
    year = {2002}
}

@manual{Corporation2000Microsoft,
    author = {Corporation, Microsoft},
    citeulike-article-id = {9939638},
    comment = {paper\_depo/fatgen103.pdf},
    day = {6},
    keywords = {file\_system, specification},
    month = dec,
    posted-at = {2011-10-23 22:46:29},
    priority = {0},
    title = {{Microsoft Extensible Firmware Initiative
FAT32 File System Specification
FAT: General Overview of On-Disk Format}},
    year = {2000}
}

@article{10.1371/journal.pone.0018882,
    abstract = {{<sec> <title>Background</title> <p>Synthetic biological systems are currently created by an ad-hoc, iterative process of specification, design, and assembly. These systems would greatly benefit from a more formalized and rigorous specification of the desired system components as well as constraints on their composition. Therefore, the creation of robust and efficient design flows and tools is imperative. We present a human readable language (Eugene) that allows for the specification of synthetic biological designs based on biological parts, as well as provides a very expressive constraint system to drive the automatic creation of composite Parts (Devices) from a collection of individual Parts.</p> </sec> <sec> <title>Results</title> <p>We illustrate Eugene's capabilities in three different areas: Device specification, design space exploration, and assembly and simulation integration. These results highlight Eugene's ability to create combinatorial design spaces and prune these spaces for simulation or physical assembly. Eugene creates functional designs quickly and cost-effectively.</p> </sec> <sec> <title>Conclusions</title> <p>Eugene is intended for forward engineering of DNA-based devices, and through its data types and execution semantics, reflects the desired abstraction hierarchy in synthetic biology. Eugene provides a powerful constraint system which can be used to drive the creation of new devices at runtime. It accomplishes all of this while being part of a larger tool chain which includes support for design, simulation, and physical device assembly.</p> </sec>}},
    author = {Bilitchenko, Lesia and Liu, Adam and Cheung, Sherine and Weeding, Emma and Xia, Bing and Leguia, Mariana and Anderson, J. Christopher and Densmore, Douglas},
    citeulike-article-id = {9887888},
    citeulike-linkout-0 = {http://dx.doi.org/10.1371/journal.pone.0018882},
    citeulike-linkout-1 = {http://dx.doi.org/10.1371\%2Fjournal.pone.0018882},
    doi = {10.1371/journal.pone.0018882},
    journal = {PLoS ONE},
    keywords = {biology, programming\_language},
    number = {4},
    posted-at = {2011-10-10 19:59:01},
    priority = {2},
    publisher = {Public Library of Science},
    title = {{Eugene – A Domain Specific Language for Specifying and Constraining Synthetic Biological Parts, Devices, and Systems}},
    url = {http://dx.doi.org/10.1371\%2Fjournal.pone.0018882},
    volume = {6},
    year = {2011}
}

@inproceedings{2010madhavapeddy_ocaml_xen_guest,
    abstract = {{The wide availability of cloud computing offers an unprecedented opportunity to rethink how we construct applications. The cloud is currently mostly used to package up existing software stacks and operating systems (e.g. LAMP) for scaling out websites. We instead view the cloud as a stable hardware platform, and present a programming framework which permits applications to be constructed to run directly on top of it without intervening software layers. Our prototype (dubbed Mirage) is unashamedly academic; it extends the Objective Caml language with storage extensions and a custom run-time to emit binaries that execute as a guest operating system under Xen. Mirage applications exhibit significant performance speedups for I/O and memory handling versus the same code running under Linux/Xen. Our results can be generalised to offer insight into improving more commonly used languages such as PHP, Python and Ruby, and we discuss lessons learnt and future directions.}},
    address = {Berkeley, CA, USA},
    author = {Madhavapeddy, Anil and Mortier, Richard and Sohan, Ripduman and Gazagnaire, Thomas and Hand, Steven and Deegan, Tim and McAuley, Derek and Crowcroft, Jon},
    booktitle = {HotCloud 2010, 2nd USENIX conference on Hot topics in Cloud computing},
    citeulike-article-id = {7986255},
    citeulike-linkout-0 = {http://anil.recoil.org/papers/2010-hotcloud-lamp.pdf},
    citeulike-linkout-1 = {http://portal.acm.org/citation.cfm?id=1863114},
    comment = {paper\_depo/2010-hotcloud-lamp.pdf},
    day = {22},
    editor = {Nahum, Erich and Xu, Dongyan},
    keywords = {op, programming\_language, software\_engineering, system\_os},
    location = {Boston, MA, USA},
    month = jun,
    pages = {11--17},
    posted-at = {2011-10-07 23:11:53},
    priority = {2},
    publisher = {USENIX Association},
    title = {Turning Down the {LAMP}: Software Specialisation for the Cloud},
    url = {http://anil.recoil.org/papers/2010-hotcloud-lamp.pdf},
    year = {2010}
}

@book{Fitzgerald2009Modelling,
    author = {Fitzgerald, John and Larsen, Peter G.},
    citeulike-article-id = {9854182},
    comment = {Didn't find the electronic verion.
---=note-separator=---
I did understand the article very well. Seems to be a language which can describe components of the system and constraints among these components.},
    isbn = {9780521899116},
    keywords = {programming\_language},
    posted-at = {2011-10-05 07:26:58},
    priority = {2},
    title = {{Modelling Systems: Practical Tools and Techniques in Software Development}},
    year = {2009}
}

@article{Larsen2009Methods,
    abstract = {{The development of distributed real-time embedded systems presents a signi-
cant practical challenge both because of the complexity of distributed computation and
because of the need to rapidly assess a wide variety of design alternatives in early stages
when requirements are often volatile. Formal methods can address some of these challenges
but are often thought to require greater initial investment and longer development cycles
than is desirable for the development of non-critical systems in highly competitive markets.
In this paper we propose an approach that takes advantage of formal modelling and analysis
technology in a lightweight way, making signicant use of readily available tools. We de-
scribe an incremental approach in which detail is progressively added to abstract system-level
specications of functional and timing properties via intermediate models that express sys-
tem architecture, concurrency and distribution. The approach is illustrated using a model
of a home automation system. The models are expressed using the Vienna Development
Method (VDM) and are validated primarily by scenario-based tests.}},
    author = {Larsen, Peter G. and Fitzgerald, John and Wolff, Sune},
    citeulike-article-id = {9854170},
    comment = {paper\_depo/Methods for the Development of Distributed.pdf},
    issn = {1673-7288},
    journal = {International Journal of Software and Informatics},
    keywords = {formal\_methods, research\_progress, specification},
    month = sep,
    pages = {305--341},
    posted-at = {2011-10-05 07:20:10},
    priority = {0},
    title = {{Methods for the Development of Distributed
Real-Time Embedded Systems Using VDM}},
    volume = {3},
    year = {2009}
}

@inproceedings{Hooman2008Formal,
    abstract = {{Abstract. To support model-based development and analysis of embedded systems, the specification language VDM++ has been extended with asynchronous communication and improved timing primitives. In addition, we have defined an interface for the co-simulation of a VDM++ model with a continuous-time model of its environment. This enables multi-disciplinary design space exploration and continuous validation of design decisions throughout the development process. We present an operational semantics which formalizes the precise meaning of the VDM extensions and the co-simulation concept.}},
    author = {Hooman, Jozef and Verhoef, Marcel},
    booktitle = {In Festschrift in honor of Willem-Paul de Roever, LNCS Festschrift Series},
    citeulike-article-id = {9854092},
    citeulike-linkout-0 = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.183.2329},
    comment = {paper\_depo/festschrift.pdf},
    keywords = {formal\_methods, software\_engineering, specification, verification},
    posted-at = {2011-10-05 05:27:12},
    priority = {5},
    title = {{Formal semantics of a VDM extension for distributed embedded systems}},
    url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.183.2329},
    year = {2008}
}

@book{Fitzgerald2005Validated,
    author = {Fitzgerald, John and Larsen, Peter G. and Mukherjee, Paul and Plat, Nico and Verhoef, Marcel},
    citeulike-article-id = {9845951},
    comment = {paper\_depo/book/Validated Designs for Object-Oriented Systems(2004)(352).pdf},
    isbn = {1-85233-881-4},
    keywords = {software\_engineering, specification},
    posted-at = {2011-10-03 04:19:29},
    priority = {2},
    title = {{Validated Designs for Object-oriented Systems}},
    year = {2005}
}

@techreport{Larsen2010VDM10,
    author = {Larsen, Peter G. and Lausdahl, Kenneth and Battle, Nick},
    citeulike-article-id = {9845939},
    comment = {paper\_depo/VDM10\_lang\_man.pdf},
    keywords = {software\_engineering, specification},
    month = apr,
    posted-at = {2011-10-03 04:16:19},
    priority = {2},
    title = {{VDM-10 Language Manual}},
    year = {2010}
}

@unpublished{MunegowdaPower,
    author = {Munegowda, Keshava},
    citeulike-article-id = {9817778},
    comment = {paper\_depo/Elc2011\_munegowda.pdf},
    keywords = {file\_system},
    location = {Bangalore},
    posted-at = {2011-09-27 04:36:45},
    priority = {2},
    school = {Texas Instruments (India) Pvt Ltd},
    title = {{Power Fail Safe FAT File System}}
}

@techreport{HayesVDM,
    abstract = {{The specification notations of VDM and Z are closely related. They both use model-based specification techniques and share a large part of their mathematical notation. However, the approaches taken to writing specifications differ in other, more subtle, ways.


We present a comparative case study of VDM and Z for specifying database systems. John Fitzgerald and Cliff Jones in their paper entitled  ” Modularising the formal description of a database system” in the proceedings of VDM '90: VDM and Z (LNCS Vol. 428, Springer-Verlag) provide the basis for the comparison.  We present equivalent Z specifications to the VDM specifications contained in their paper.  


The approach taken in writing the Z specifications is to reuse as much as possible of the Z mathematical toolkit and to build the system specification from specifications of components of the system.


In their paper, Fitzgerald and Jones emphasise their modularisation facilities. While the facilities for modularisation in Z are not as powerful, they are adequate for the specification of the database systems presented.}},
    author = {Hayes, Ian},
    citeulike-article-id = {9817776},
    comment = {paper\_depo/10.1.1.83.4361.pdf

This one contains annotation for VDM.},
    keywords = {formal\_methods, programming\_language, verification},
    location = {Department of Computer Science},
    posted-at = {2011-09-27 04:35:20},
    priority = {2},
    school = {University of Queensland, Brisbane, 4072 Australia},
    title = {{VDM and Z: A Comparative Case Study}}
}

@techreport{Cunha2007Verified,
    abstract = {{The verification grand challenge proposed by Prof. Tony Hoare sets the stage for the program verification community to embark upon a collaborative effort to build verifiable programs. In recent meetings it has been suggested that the community should concentrate on the verification of the Linux kernel, but this would be an impossible task to do in a couple of years due to this kernel's size. So, Rajeev Joshi and Gerald Holzmann [3] decided to propose a  ” mini challenge”: build a verifiable file system.

There are several reasons why a file system is more attractive as first target for verification.  Firstly, most modern file systems have a well-defined interface conforming to the POSIX standard.  Thus, writing a formal specification for a POSIX-compliant file system would require far less effort than writing a kernel specification. Secondly, the algorithms and data structures used in file system design are well understood and a verifiable file system implementation could be written from scratch. Alternatively, researchers could choose an existing file system and attempt to verify it. Thirdly, although file systems are only a small portion of an operating system, they are complex enough for ensuring reliability in the presence of concurrent access, unexpected power or hardware failure etc to be nontrivial. Finally, since almost all data on modern computers are now managed by file systems, their correctness is of great importance, both from the standpoint of reliability as well as security. Development of a verified file system would therefore be of great value.  

Most modern file systems are written to comply with the POSIX standard for file systems.  This standard specifies a set of function signatures, along with a behavioral description of each function. However, these behavioral descriptions are given as informal English prose, and are therefore too ambiguous and incomplete to be useful in a verification effort. So we have writen a formal specification of some POSIX standard functions (eg. mkdir, open, read, write) using the modeling language VDM++ [9], although some features of the POSIX standard are not completely modeled.}},
    author = {Cunha, Simao and Rodrigues, Luis and Silva, Augusto},
    citeulike-article-id = {9813588},
    comment = {paper\_deop/vfs\_my\_V1.0.vpp.pdf},
    day = {27},
    keywords = {file\_system, formal\_methods},
    location = {Department of Informatics},
    month = sep,
    posted-at = {2011-09-26 18:50:42},
    priority = {4},
    school = {University of Minho},
    title = {{Verified File-System v1.0}},
    year = {2007}
}

@electronic{Tweedie1998Journaling,
    abstract = {{This paper describes a work-in-progress to design and implement a transactional metadata journal for the Linux ext2fs filesystem. We review the problem of recovering filesystems after a crash, and describe a design intended to increase ext2fs's speed and reliability of crash recovery by adding a transactional journal to the filesystem.}},
    author = {Tweedie, Stephen},
    citeulike-article-id = {3280765},
    citeulike-linkout-0 = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.42.5877},
    comment = {dropbox/paper\_depo/journal-design.pdf
---=note-separator=---
看这篇文章的目的在于了解Journaling的基本原理和具体表现，但看完后还是不很了解。有点让人费解的文章。},
    journal = {In The Fourth Annual Linux Expo},
    keywords = {file\_system},
    month = may,
    posted-at = {2011-08-31 10:36:05},
    priority = {0},
    title = {{Journaling the Linux ext2fs Filesystem}},
    url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.42.5877},
    year = {1998}
}

@incollection{Joshi08,
    abstract = {{We propose tackling a ``mini challenge'' problem: a nontrivial verification effort that can be completed in 2-3 years, and will help establish notational standards, common formats, and libraries of benchmarks that will be essential in order for the verification community to collaborate on meeting Hoare's 15-year verification grand challenge. We believe that a suitable candidate for such a mini challenge is the development of a filesystem that is verifiably reliable and secure. The paper argues why we believe a filesystem is the right candidate for a mini challenge and describes a project in which we are building a small embedded filesystem for use with flash memory.}},
    address = {Berlin, Heidelberg},
    author = {Joshi, Rajeev and Holzmann, Gerard},
    booktitle = {Verified Software: Theories, Tools, Experiments},
    chapter = {A Mini Challenge: Build a Verifiable Filesystem},
    citeulike-article-id = {5076256},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=1417078},
    citeulike-linkout-1 = {http://dx.doi.org/10.1007/978-3-540-69149-5\_6},
    citeulike-linkout-2 = {http://www.springerlink.com/content/c3l5p5201w778616},
    comment = {(private-note)介绍了为什么选择verifying flash file system的原因，对已有的工作做了一些总结。
可以选择verify existing file system，也可以build a new file system from scratch。

According to this paper, existing specifications use Z or ACL2 and none of them has completely model the system to include error code, file permission and (journaling, wear leveling and power loss recovery machanism).},
    doi = {10.1007/978-3-540-69149-5\_6},
    editor = {Meyer, Bertrand and Woodcock, Jim},
    isbn = {978-3-540-69147-1},
    journal = {Verified Software: Theories, Tools, Experiments},
    keywords = {file\_system, formal\_methods},
    pages = {49--56},
    posted-at = {2011-08-03 10:38:25},
    priority = {0},
    publisher = {Springer Berlin / Heidelberg},
    series = {Lecture Notes in Computer Science},
    title = {{Verified Software: Theories, Tools, Experiments}},
    url = {http://dx.doi.org/10.1007/978-3-540-69149-5\_6},
    volume = {4171},
    year = {2008}
}

@techreport{Intel2004,
    author = {Intel},
    citeulike-article-id = {3039853},
    institution = {Intel Coorporation},
    keywords = {file\_system, formal\_methods},
    posted-at = {2011-08-02 22:26:39},
    priority = {2},
    title = {{Intel Flash File System Core Reference Guide, version 1}},
    type = {Technical Report 304436001},
    year = {Oct. 2004}
}

@article{Rinard2008Technical,
    abstract = {{An abstract is not available.}},
    address = {New York, NY, USA},
    author = {Rinard, Martin C.},
    citeulike-article-id = {8698141},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=1409381},
    citeulike-linkout-1 = {http://dx.doi.org/10.1145/1409360.1409381},
    doi = {10.1145/1409360.1409381},
    issn = {0001-0782},
    journal = {Commun. ACM},
    key = {Rinard08},
    keywords = {programming\_language, software\_engineering},
    month = dec,
    pages = {86},
    posted-at = {2011-01-28 02:27:33},
    priority = {2},
    publisher = {ACM},
    title = {{Technical perspective: Patching program errors}},
    url = {http://dx.doi.org/10.1145/1409360.1409381},
    volume = {51},
    year = {2008}
}

@unpublished{XIREN10,
    abstract = {{Formal specification is widely employed in the construction of high-quality
software. However, there is often a huge gap between formal specification
and actual implementation. While there is already a vast body of work on
software testing and verification, the task to ensure that an
implementation indeed meets its specification is still undeniably of great
difficulty.  ATS is a programming language equipped with a highly
expressive type system that allows the programmer to specify and implement
and then verify within the language itself that an implementation meets its
specification.  In this paper, we present largely through examples a
programmer-centric style of program verification that puts emphasis on
requesting the programmer to explain in a literate fashion why his or her
code works. This is a solid step in the pursuit of software construction
that is verifiably correct according to specification.}},
    author = {Ren, Zhiqiang and Xi, Hongwei},
    citeulike-article-id = {8698097},
    keywords = {programming\_language, verification},
    month = dec,
    posted-at = {2011-01-28 02:02:14},
    priority = {0},
    title = {{A Programmer-Centric Approach to Program Verification in ATS}},
    year = {2010}
}

@inbook{MLWP,
    abstract = {{The new edition of this successful and established textbook retains its two
original intentions of explaining how to program in the ML language, and
teaching the fundamentals of functional programming. The major change is the
early and prominent coverage of modules, which the author extensively uses
throughout. In addition, Paulson has totally rewritten the first chapter to
make the book more accessible to students who have no experience of
programming languages. The author describes the main features of new Standard
Library for the revised version of ML, and gives many new examples, e.g.
polynomial arithmetic and new ways of treating priority queues. Finally he has
completely updated the references. Dr. Paulson has extensive practical
experience of ML, and has stressed its use as a tool for software engineering;
the book contains many useful pieces of code, which are freely available (via
Internet) from the author. He shows how to use lists, trees, higher-order
functions and infinite data structures. He includes many illustrative and
practical examples, covering sorting, matrix operations, and polynomial
arithmetic. He describes efficient functional implementations of arrays,
queues, and priority queues. Larger examples include a general top-down
parser, a lambda-calculus reducer and a theorem prover. A chapter is devoted
to formal reasoning about functional programs. The combination of careful
explanation and practical advice will ensure that this textbook continues to
be the preferred text for many courses on ML for students at all levels.}},
    author = {Paulson, Lawrence C.},
    chapter = {3},
    citeulike-article-id = {2990731},
    citeulike-linkout-0 = {http://www.amazon.ca/exec/obidos/redirect?tag=citeulike09-20\&amp;path=ASIN/052156543X},
    citeulike-linkout-1 = {http://www.amazon.de/exec/obidos/redirect?tag=citeulike01-21\&amp;path=ASIN/052156543X},
    citeulike-linkout-2 = {http://www.amazon.fr/exec/obidos/redirect?tag=citeulike06-21\&amp;path=ASIN/052156543X},
    citeulike-linkout-3 = {http://www.amazon.jp/exec/obidos/ASIN/052156543X},
    citeulike-linkout-4 = {http://www.amazon.co.uk/exec/obidos/ASIN/052156543X/citeulike00-21},
    citeulike-linkout-5 = {http://www.amazon.com/exec/obidos/redirect?tag=citeulike07-20\&path=ASIN/052156543X},
    citeulike-linkout-6 = {http://www.worldcat.org/isbn/052156543X},
    citeulike-linkout-7 = {http://books.google.com/books?vid=ISBN052156543X},
    citeulike-linkout-8 = {http://www.amazon.com/gp/search?keywords=052156543X\&index=books\&linkCode=qs},
    citeulike-linkout-9 = {http://www.librarything.com/isbn/052156543X},
    day = {28},
    edition = {2},
    howpublished = {Paperback},
    isbn = {052156543X},
    keywords = {programming\_language},
    month = jun,
    posted-at = {2011-01-27 22:11:27},
    priority = {2},
    publisher = {Cambridge University Press},
    title = {{ML for the Working Programmer}},
    url = {http://www.worldcat.org/isbn/052156543X},
    year = {1996}
}

@misc{Ammons2003Debugging,
    abstract = {{Program verification tools (such as model checkers and static analyzers)
can find many errors in programs. These tools need formal
specifications of correct program behavior, but writing a correct
specification is difficult, just as writing a correct program is difficult.
Thus, just as we need methods for debugging programs, we
need methods for debugging specifications.}},
    author = {Ammons, G. and Mandein, D. and Bodik, R. and Larus, J.},
    citeulike-article-id = {693859},
    citeulike-linkout-0 = {http://citeseer.ist.psu.edu/ammons03debugging.html},
    citeulike-linkout-1 = {http://citeseer.lcs.mit.edu/ammons03debugging.html},
    citeulike-linkout-2 = {http://citeseer.ifi.unizh.ch/ammons03debugging.html},
    citeulike-linkout-3 = {http://citeseer.comp.nus.edu.sg/ammons03debugging.html},
    keywords = {programming\_language, software\_engineering},
    posted-at = {2011-01-20 21:17:52},
    priority = {0},
    title = {{Debugging Temporal Specifications with Concept Analysis}},
    url = {http://citeseer.ist.psu.edu/ammons03debugging.html},
    year = {2003}
}

@inproceedings{Rayner2005OMG,
    author = {Rayner, Manny and Hockey, Beth A. and Chatzichrisafis, Nikos and Farrell, Kim},
    booktitle = {Version 1.3, {\copyright} 1999 Object Management Group, Inc},
    citeulike-article-id = {8486971},
    citeulike-linkout-0 = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.109.6448},
    keywords = {formal\_methods, programming\_language},
    posted-at = {2010-12-27 01:09:32},
    priority = {2},
    title = {{OMG Unified Modeling Language Specification}},
    url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.109.6448},
    year = {2005}
}

@article{Kuncak2006Modular,
    abstract = {{We describe a technique that enables the focused application of multiple analyses  to different modules in the same program. In our approach, each module encapsulates  one or more data structures and uses membership in abstract sets to characterize how objects  participate in data structures. Each analysis verifies that the implementation of the module  1) preserves important internal data structure consistency properties and 2) correctly implements  an interface that uses formulas in a set algebra to characterize the effects of operations  on the encapsulated data structures. Collectively, the analyses use the set algebra to 1) characterize  how objects participate in multiple data structures and to 2) enable the inter-analysis  communication required to verify properties that depend on multiple modules analyzed by  different analyses.}},
    author = {Kuncak, Viktor and Lam, Patrick and Zee, Karen and Rinard, Martin},
    citeulike-article-id = {8484562},
    citeulike-linkout-0 = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.59.4566},
    journal = {IEEE Transactions on Software Engineering},
    keywords = {formal\_methods},
    posted-at = {2010-12-25 19:53:25},
    priority = {2},
    title = {{Modular Pluggable Analyses for Data Structure Consistency}},
    url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.59.4566},
    volume = {32},
    year = {2006}
}

@inproceedings{Bouillaguet2007Using,
    abstract = {{Abstract. This paper presents our integration of efficient resolution-based theorem provers into the Jahob data structure verification system. Our experimental results show that this approach enables Jahob to automatically verify the correctness of a range of complex dynamically instantiable data structures, including data structures such as hash tables and search trees, without the need for interactive theorem proving or techniques tailored to individual data structures. Our primary technical results include: (1) a translation from higher-order logic to first-order logic that enables the application of resolution-based theorem provers and (2) a proof that eliminating type (sort) information in formulas is both sound and complete, even in the presence of a generic equality operator. Moreover, our experimental results show that the elimination of this type information dramatically decreases the time required to prove the resulting formulas. These techniques enabled us to verify complex correctness properties of Java programs such as a mutable set implemented as an imperative linked list, a finite map implemented as a functional ordered tree, a hash table with a mutable array, and a simple library system example that uses these container data structures. Our system verifies (in a matter of minutes) that data structure operations correctly update the finite map, that they preserve data structure invariants (such as ordering of elements, membership in appropriate hash table buckets, or relationships between sets and relations), and that there are no run-time errors such as null dereferences or array out of bounds accesses. 1}},
    author = {Bouillaguet, Charles and Kuncak, Viktor and Wies, Thomas and Zee, Karen and Rinard, Martin},
    booktitle = {In Byron Cook and Andreas Podelski, editors, Verification, Model Checking, and Abstract Interpretation, LNCS 4349},
    citeulike-article-id = {8484560},
    citeulike-linkout-0 = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.110.3894},
    keywords = {formal\_methods},
    pages = {74--88},
    posted-at = {2010-12-25 19:52:33},
    priority = {2},
    title = {{Using first-order theorem provers in the Jahob data structure verification system}},
    url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.110.3894},
    year = {2007}
}

@electronic{ZeeRuntime,
    abstract = {{Abstract. The process of verifying that a program conforms to its specification is often hampered by errors in both the program and the specification. A runtime checker that can evaluate formal specifications can be useful for quickly identifying such errors. This paper describes our preliminary experience with incorporating run-time checking into the Jahob verification system and discusses some lessons we learned in this process. One of the challenges in building a runtime checker for a program verification system is that the language of invariants and assertions is designed for simplicity of semantics and tractability of proofs, and not for run-time checking. Some of the more challenging constructs include existential and universal quantification, set comprehension, specification variables, and formulas that refer to past program states. In this paper, we describe how we handle these constructs in our runtime checker, and describe directions for future work. 1}},
    author = {Zee, Karen and Kuncak, Viktor and Taylor, Michael and Rinard, Martin},
    citeulike-article-id = {8484559},
    citeulike-linkout-0 = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.72.3976},
    keywords = {formal\_methods},
    posted-at = {2010-12-25 19:51:11},
    priority = {2},
    title = {{Runtime Checking for Program Verification}},
    url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.72.3976}
}

@techreport{Wies2006Verifying,
    abstract = {{One of the main challenges in the verification of software systems is the analysis of statically unbounded data structures with dynamic memory allocation, such as linked data structures and arrays. We describe Bohne, a new analysis for verifying data structures. Bohne verifies data structure operations and shows that 1) the operations preserve data structure invariants and 2) the operations satisfy their specifications expressed in terms of changes to the set of objects stored in the data structure. During the analysis, Bohne infers loop invariants in the form of disjunctions of universally quantified Boolean combinations of formulas, represented as sets of binary decision diagrams. To synthesize loop invariants of this form, Bohne uses a combination of decision procedures for Monadic Second-Order Logic over trees, SMT-LIB decision procedures (currently CVC Lite), first-order provers such as SPASS and E, and the automated reasoner within the Isabelle interactive theorem prover. This architecture shows that synthesized loop invariants can serve as a useful communication mechanism between different decision procedures. In addition, Bohne uses field constraint analysis, a combination mechanism that enables the use of uninterpreted function symbols within formulas of Monadic Second-Order Logic over trees. Using Bohne, we have verified operations on data structures such as linked lists with iterators and back pointers, trees with and without parent pointers, two-level skip lists, array data structures, and sorted lists. We have deployed Bohne in the Hob and Jahob data structure analysis systems, enabling us to combine Bohne with analyses of data structure clients and apply it in the context of larger programs. This paper describes the Bohne algorithm, the techniques that Bohne uses to reduce the amount of annotations and the running time of the analysis. 1}},
    author = {Wies, Thomas and Kuncak, Viktor and Zee, Karen and Rinard, Martin and Podelski, Andreas},
    citeulike-article-id = {8484558},
    citeulike-linkout-0 = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.71.150},
    journal = {In Workshop on Heap Abstraction and Verification (collocated with ETAPS},
    keywords = {formal\_methods, programming\_language},
    posted-at = {2010-12-25 19:49:07},
    priority = {2},
    title = {{On verifying complex properties using symbolic shape analysis}},
    url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.71.150},
    year = {2006}
}

@electronic{LamStatic,
    abstract = {{Sets of objects are an intuitive foundation for many object-oriented design formalisms, serving as a key concept for describing elements of the design and promoting communication between members of the development team. It may be natural for the sets of the objects in the design to correspond to the sets of objects in the implementation. In practice, however, the object structure of the implementation is much more complex than that of the design. Moreover, the lack of an enforced connection between the implementation and the design enables the implementation to diverge from the design, rendering the design unreliable as a source of information about the implementation. Hob allows developers to express and verify the connection between abstract sets of design objects and concrete sets of implementation objects. Abstraction maps define the meaning of the design sets in terms of the objects in the implementation, enabling the elimination of implementation complexity not relevant to the design. An abstract set specification language enables the developer to state important relationships (such as inclusion and disjointness) between abstract sets of objects; our verification system statically checks that the implementation correctly preserves these design-level correctness properties. We have implemented Hob and used it to develop several software systems. Our experience shows that Hob enables the effective expression and verification of precise design constraints that manifest themselves as important correctness properties that the implemented system is guaranteed to preserve. 1}},
    author = {Lam, Patrick and Rinard, Martin},
    citeulike-article-id = {8484557},
    citeulike-linkout-0 = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.153.6085},
    keywords = {formal\_methods, programming\_language},
    posted-at = {2010-12-25 19:45:26},
    priority = {2},
    title = {{Static Verification of Design Constraints and Software Correctness Properties in the Hob System}},
    url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.153.6085}
}

@electronic{Zee08b,
    abstract = {{The Jahob program verification system leverages state of the art automated theorem provers, shape analysis, and decision procedures to check that programs conform to their specifications. By combining a rich specification language with a diverse collection of verification technologies, Jahob makes it possible to verify complex properties of programs that manipulate linked data structures. We present our results using Jahob to achieve full functional verification of a collection of linked data structures. 1}},
    author = {Zee, Karen and Kuncak, Viktor and Rinard, Martin},
    citeulike-article-id = {8484556},
    citeulike-linkout-0 = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.154.2476},
    keywords = {formal\_methods, programming\_language},
    posted-at = {2010-12-25 19:41:58},
    priority = {2},
    title = {{Verifying Linked Data Structure Implementations}},
    url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.154.2476}
}

@inproceedings{Zee08a,
    abstract = {{We present the first verification of full functional correctness for a range of linked data structure implementations, including mutable lists, trees, graphs, and hash tables. Specifically, we present the use of the Jahob verification system to verify formal specifications, written in classical higher-order logic, that completely capture the desired behavior of the Java data structure implementations (with the exception of properties involving execution time and/or memory consumption). Given that the desired correctness properties include intractable constructs such as quantifiers, transitive closure, and lambda abstraction, it is a challenge to successfully prove the generated verification conditions. Our Jahob verification system uses integrated reasoning to split each verification condition into a conjunction of simpler subformulas, then apply a diverse collection of specialized decision procedures,}},
    author = {Zee, Karen and Kuncak, Viktor and Rinard, Martin C.},
    booktitle = {In ACM Conf. Programming Language Design and Implementation (PLDI},
    citeulike-article-id = {8484555},
    citeulike-linkout-0 = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.149.1914},
    keywords = {formal\_methods, programming\_language},
    posted-at = {2010-12-25 19:40:05},
    priority = {2},
    title = {{Full functional verification of linked data structures}},
    url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.149.1914},
    year = {2008}
}

@inproceedings{Zee09,
    abstract = {{We present an integrated proof language for guiding the actions of multiple reasoning systems as they work together to prove complex correctness properties of imperative programs. The language operates in the context of a program verification system that uses multiple reasoning systems to discharge generated proof obligations. It is designed to 1) enable developers to resolve key choice points in complex program correctness proofs, thereby enabling automated reasoning systems to successfully prove the desired correctness properties; 2) allow developers to identify key lemmas for the reasoning systems to prove, thereby guiding the reasoning systems to find an effective proof decomposition; 3) enable multiple reasoning systems to work together productively to prove a single correctness property by providing a mechanism that developers can use to divide the property into lemmas, each of which is suitable for}},
    author = {Zee, Karen and Kuncak, Viktor and Rinard, Martin C.},
    booktitle = {In PLDI'09},
    citeulike-article-id = {8484554},
    citeulike-linkout-0 = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.149.3494},
    keywords = {formal\_methods, programming\_language},
    pages = {338--351},
    posted-at = {2010-12-25 19:35:04},
    priority = {2},
    title = {{An integrated proof language for imperative programs}},
    url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.149.3494}
}

@inproceedings{Ste09,
    abstract = {{Finding subclasses of formul{\ae} for which the SAT problemcan be solved in polynomial time has been an importantproblem in computer science. We present a new hierarchyof propositional formul{\ae} subclasses for which the SAT andcounting SAT problems can be solved in polynomial time.Our tractable subclasses are those propositional formul{\ae}in conjunctive normal form where any set of k + 1 clausesare related, i.e., there exists at least one literal in one clausethat appears negated in another clause of the considered setof k + 1 clauses. We say this subclass of formul{\ae} is of rankk and it is different from previously known subclasses thatare solvable in polynomial time. This is an improvementover the SAT Dichotomy Theorem and the counting SATDichotomy Theorem, since our subclass can be moved outfrom the NP-complete class to the P class. The membershipproblem for this new subclass can be solved in O(n · lk+1),where n, l and k are the number of variables, clauses andthe rank (1 ≤ k ≤ l − 1), respectively. We give an efficientalgorithm to approximate the number of assignments forany arbitrary conjunctive normal form propositional formulaby an upper bound.}},
    author = {Andrei, Stefan and Grigoras, Gheorghe and Rinard, Martin and Yap, Roland},
    booktitle = {11th International Symposium on Symbolic and Numeric Algorithms for Scientific Computing (SYNASC'09)},
    citeulike-article-id = {8484553},
    keywords = {complexity},
    location = {Timisoara, Romania},
    month = sep,
    posted-at = {2010-12-25 19:30:53},
    priority = {2},
    title = {{A Hierarchy of Tractable Subclasses for SAT and Counting SAT Problems}},
    year = {2009}
}

@electronic{Rey02,
    abstract = {{In joint work with Peter O\&\#039;Hearn and others, based on early ideas of Burstall, we have developed an extension of Hoare logic that permits reasoning about low-level imperative programs that use shared mutable data structure.}},
    author = {Reynolds, John},
    citeulike-article-id = {3426195},
    citeulike-linkout-0 = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.11.5322},
    keywords = {formal\_methods, logic},
    pages = {55--74},
    posted-at = {2010-12-24 04:50:34},
    priority = {2},
    title = {{Separation Logic: A Logic for Shared Mutable Data Structures}},
    url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.11.5322},
    year = {2002}
}

@inproceedings{Huu08,
    author = {Nguyen, Huu H. and Chin, Wei-Ngan},
    booktitle = {20th International Conference on Computer Aided Verification (CAV) 2008},
    citeulike-article-id = {8482072},
    keywords = {formal\_methods},
    location = {Princeton, USA},
    month = jul,
    posted-at = {2010-12-24 04:47:21},
    priority = {2},
    title = {{Enhancing Program Verification with Lemmas}},
    year = {2008}
}

@inproceedings{Cok04,
    abstract = {{The ESC/Java tool was a lauded advance in effective static checking of realistic Java programs,  but has become out-of-date with respect to Java and the Java Modeling Language (JML). The  ESC/Java2 project, whose progress is described in this paper, builds on the final release of ESC/Java  from DEC/SRC in several ways. It parses all of JML, thus can be used with the growing body of  JML-annotated Java code; it has additional static checking capabilities; and it has been designed, constructed,  and documented in such a way as to improve the tool's usability to both users and researchers.}},
    author = {Cok, David R. and Kiniry, Joseph R.},
    booktitle = {In Construction and Analysis of Safe, Secure and Interoperable Smart Devices: International Workshop, CASSIS 2004},
    citeulike-article-id = {6957041},
    citeulike-linkout-0 = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.10.8374},
    keywords = {formal\_methods},
    posted-at = {2010-12-24 03:35:28},
    priority = {2},
    title = {{ESC/Java2: Uniting ESC/Java and JML - Progress and issues in building and using ESC/Java2}},
    url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.10.8374},
    volume = {3362},
    year = {2004}
}

@electronic{Fla02,
    abstract = {{Software development and maintenance are costly endeavors. The cost can be reduced if more software defects are detected earlier in the development cycle. This paper introduces the Extended Static Checker for Java (ESC/Java), an experimental compile-time program checker that finds common programming errors. The checker is powered by verification-condition generation and automatic theoremproving techniques. It provides programmers with a simple annotation language with which programmer design decisions can be expressed formally. ESC/Java examines the annotated software and warns of inconsistencies between the design decisions recorded in the annotations and the actual code, and also warns of potential runtime errors in the code. This paper gives an overview of the checker architecture and annotation language and describes our experience applying the checker to tens of thousands of lines of Java programs.}},
    author = {Flanagan, Cormac and Rustan and Rustan, K. and Leino, M. and Lillibridge, Mark and Nelson, Greg and Saxe, James B. and Stata, Raymie},
    citeulike-article-id = {8482039},
    citeulike-linkout-0 = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.19.162},
    keywords = {formal\_methods},
    posted-at = {2010-12-24 03:30:37},
    priority = {2},
    title = {{Extended Static Checking for Java}},
    url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.19.162},
    year = {2002}
}

@inproceedings{Pol06,
    abstract = {{Abstract. Many state-based specification languages, including the Java Modeling Language (JML), contain at their core specification constructs familiar to most computer science and software engineering undergraduates: e.g., assertions, pre- and postconditions, and invariants. Unfortunately, these constructs are not sufficiently expressive to permit formal modular verification of programs written in modern object-oriented languages like Java. The necessary extra constructs for specifying an object-oriented module include the less familiar frame properties, datagroups, and ghost and model fields. These constructs help specifiers deal with potential problems related to, e.g., unexpected side effects, aliasing, class invariants, inheritance, and lack of information hiding. This tutorial focuses on these constructs, explaining their meaning while illustrating how they can be used to address the stated problems. 1}},
    author = {Poll, Erik and Chalin, Patrice and Cok, David and Kiniry, Joe and Leavens, Gary T.},
    booktitle = {In Formal Methods for Components and Objects (FMCO) 2005, Revised Lectures, volume 4111 of LNCS},
    citeulike-article-id = {8482037},
    citeulike-linkout-0 = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.102.4611},
    keywords = {formal\_methods},
    pages = {342--363},
    posted-at = {2010-12-24 03:27:40},
    priority = {2},
    title = {{Beyond assertions: Advanced specification and verification with JML and ESC/Java2}},
    url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.102.4611},
    volume = {4111},
    year = {2006}
}

@inproceedings{Kin06,
    abstract = {{Usability is a key concern in the development of verification tools. In this paper, we present an usability extension for the verification tool ESC/Java2. This enhancement is not achieved through extensions to the underlying logic or calculi of ESC/Java2, but instead we focus on its human interface facets. User awareness of the soundness and completeness of the tool is vitally important in the verification process, and lack of information about such is one of the most requested features from ESC/Java2 users, and a primary complaint from ESC/Java2 critics. Areas of unsoundness and incompleteness of ESC/Java2 exist at three levels: the level of the underlying logic; the level of translation of program constructs into verification conditions; and at the level of the theorem prover. The user must be made aware of these issues for each particular part of the source code analysed in order to have confidence in the verification process. Our extension to ESC/Java2 provides clear warnings to the user when unsound or incomplete reasoning may be taking place. 1.}},
    author = {Kiniry, Joseph R. and Morkan, Alan E. and Denby, Barry},
    booktitle = {In: Proceedings of the Fifth International Workshop on Specification and Verification of Component Based Systems (SAVCBS},
    citeulike-article-id = {8482036},
    citeulike-linkout-0 = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.116.5308},
    keywords = {formal\_methods},
    posted-at = {2010-12-24 03:23:00},
    priority = {2},
    title = {{Soundness and Completeness Warnings in ESC/Java2}},
    url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.116.5308},
    year = {2006}
}

@article{Fla02,
    abstract = {{Software development and maintenance are costly endeavors. The cost can be reduced if more software defects are detected earlier in the development cycle. This paper introduces the Extended Static Checker for Java (ESC/Java), an experimental compile-time program checker that finds common programming errors. The checker is powered by verification-condition generation and automatic theorem-proving techniques. It provides programmers with a simple annotation language with which programmer design decisions can be expressed formally. ESC/Java examines the annotated software and warns of inconsistencies between the design decisions recorded in the annotations and the actual code, and also warns of potential runtime errors in the code. This paper gives an overview of the checker architecture and annotation language and describes our experience applying the checker to tens of thousands of lines of Java programs.}},
    address = {New York, NY, USA},
    author = {Flanagan, Cormac and Rustan and Lillibridge, Mark and Nelson, Greg and Saxe, James B. and Stata, Raymie},
    citeulike-article-id = {514997},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=543552.512558},
    citeulike-linkout-1 = {http://dx.doi.org/10.1145/543552.512558},
    doi = {10.1145/543552.512558},
    isbn = {1581134630},
    issn = {0362-1340},
    journal = {SIGPLAN Not.},
    keywords = {formal\_methods},
    month = may,
    number = {5},
    pages = {234--245},
    posted-at = {2010-12-23 04:44:31},
    priority = {2},
    publisher = {ACM},
    title = {{Extended static checking for Java}},
    url = {http://dx.doi.org/10.1145/543552.512558},
    volume = {37},
    year = {2002}
}

@book{Jon91,
    abstract = {{An abstract is not available.}},
    address = {Upper Saddle River, NJ, USA},
    author = {Jones, Cliff B.},
    citeulike-article-id = {4393119},
    citeulike-linkout-0 = {http://homepages.cs.ncl.ac.uk/cliff.jones/ftp-stuff/Jones1990.pdf},
    citeulike-linkout-1 = {http://portal.acm.org/citation.cfm?id=94062},
    edition = {Second},
    isbn = {0-13-880733-7},
    keywords = {formal\_methods},
    posted-at = {2010-12-23 01:15:40},
    priority = {2},
    publisher = {Prentice-Hall, Inc.},
    title = {{Systematic software development using VDM}},
    url = {http://homepages.cs.ncl.ac.uk/cliff.jones/ftp-stuff/Jones1990.pdf},
    year = {1990}
}

@inproceedings{Gut93,
    abstract = {{Preface Building software often seems harder than it ought to be. It takes longerthan expected, the software\&\#039;s functionality and performance are not as wonderful as hoped, and the software is not particularly malleable or easyto maintain. It does not have to be that way. This book is about programming, and the role that formal specificationscan play in making programming easier and programs better. The intended audience is practicing programmers and students in undergraduate or basicgraduate courses in software engineering or formal methods. To make the book accessible to such an audience, we have not presumed that thereader has formal training in mathematics or computer science. We have, however, presumed some programming experience.}},
    author = {Guttag, J. V. and Horning, J. J. and Withs and Jones, K. D. and Modet, A. and Wing, J. M.},
    booktitle = {Texts and Monographs in Computer Science},
    citeulike-article-id = {8470352},
    citeulike-linkout-0 = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.137.5123},
    keywords = {formal\_methods},
    posted-at = {2010-12-23 01:10:44},
    priority = {2},
    title = {{Larch: Languages and tools for formal specification}},
    url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.137.5123},
    year = {1993}
}

@manual{ISO02,
    citeulike-article-id = {8470341},
    keywords = {formal\_methods},
    organization = {ISO/IEC 13568:2002, Intl. Standards Organization},
    posted-at = {2010-12-23 00:58:27},
    priority = {2},
    title = {{Z Formal Specification Notation - Syntax, Type System an Semantics}},
    year = {2002}
}

@inproceedings{OMG03b,
    booktitle = {Unified Modeling Language, v2.0},
    citeulike-article-id = {8470326},
    citeulike-linkout-0 = {http://www.omg.org},
    keywords = {formal\_methods},
    month = sep,
    organization = {Object Management Group},
    posted-at = {2010-12-23 00:48:42},
    priority = {2},
    title = {{Object Constraint language specification}},
    url = {http://www.omg.org},
    year = {2003}
}

@article{Win90,
    abstract = {{Formal methods used in developing computer systems (i.e. mathematically based techniques for describing system properties) are defined, and their role is delineated. Formal specification languages, which provide the formal method's mathematical basis, are examined. Certain pragmatic concerns about formal methods and their users, uses, and characteristics are discussed. Six well-known or commonly used formal methods are illustrated by simple examples. They are Z, VDM, Larch, temporal logic, CSP, and transition axioms}},
    author = {Wing, Jeannette M.},
    booktitle = {Computer},
    citeulike-article-id = {4384532},
    citeulike-linkout-0 = {http://www.cs.cmu.edu/\~{}wing/publications/Wing90a.pdf},
    citeulike-linkout-1 = {http://dx.doi.org/10.1109/2.58215},
    citeulike-linkout-2 = {http://ieeexplore.ieee.org/xpls/abs\_all.jsp?arnumber=58215},
    doi = {10.1109/2.58215},
    journal = {Computer},
    keywords = {formal\_methods},
    number = {9},
    pages = {8--24},
    posted-at = {2010-12-23 00:43:57},
    priority = {2},
    publisher = {IEEE Press},
    title = {{A specifier's introduction to formal methods}},
    url = {http://www.cs.cmu.edu/\~{}wing/publications/Wing90a.pdf},
    volume = {23},
    year = {1990}
}

@book{Pre09,
    abstract = {{For almost three decades, Roger Pressman's "Software Engineering: A Practitioner's Approach" has been the world's leading textbook in software engineering. The new seventh edition represents a major restructuring and update of previous editions, solidifying the book's position as the most comprehensive guide to this important subject. The seventh edition of "Software Engineering: A Practitioner's Approach" has been designed to consolidate and restructure the content introduced over the past two editions of the book. The chapter structure will return to a more linear presentation of software engineering topics with a direct emphasis on the major activities that are part of a generic software process. Content will focus on widely used software engineering methods and will de-emphasize or completely eliminate discussion of secondary methods, tools and techniques. The intent is to provide a more targeted, prescriptive, and focused approach, while attempting to maintain "SEPA"'s reputation as a comprehensive guide to software engineering. The book will be organized in five (5) parts - Process, Modeling, Quality Management, Project Management, and Advanced Topics. The chapter count will remain at 32, unchanged from the sixth edition. However, eight new chapters have been developed and another six chapters have undergone major or moderate revisions. The remaining chapters have undergone minor edits/updates.}},
    author = {Pressman, Roger S.},
    booktitle = {Software Engineering: A Practitioner's Approach, 7th International edition},
    citeulike-article-id = {8468972},
    day = {1},
    edition = {Seventh},
    howpublished = {Paperback},
    isbn = {0071267824},
    keywords = {formal\_methods},
    month = apr,
    posted-at = {2010-12-22 23:06:22},
    priority = {2},
    title = {{Software Engineering: A Practitioner's Approach}},
    year = {2009}
}

@inproceedings{Ryzhyk2007Formalising,
    abstract = {{The lack of well-defined protocols for interaction with the operating system is a common source of defects in device drivers. In this paper we investigate the use of a formal language to define these protocols unambiguously. We present a language that allows us to convey all important requirements for driver behaviour in a compact specification and that can be readily understood by software engineers. It is intended to close the communication gap between OS and driver developers and enable more reliable device drivers.}},
    address = {New York, NY, USA},
    author = {Ryzhyk, Leonid and Kuz, Ihor and Heiser, Gernot},
    booktitle = {Proceedings of the 4th workshop on Programming languages and operating systems},
    citeulike-article-id = {3441272},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=1376803},
    citeulike-linkout-1 = {http://dx.doi.org/10.1145/1376789.1376803},
    doi = {10.1145/1376789.1376803},
    isbn = {978-1-59593-922-7},
    keywords = {system\_os, verification},
    location = {Stevenson, Washington},
    pages = {1--5},
    posted-at = {2010-11-30 05:27:40},
    priority = {2},
    publisher = {ACM},
    series = {PLOS '07},
    title = {{Formalising device driver interfaces}},
    url = {http://dx.doi.org/10.1145/1376789.1376803},
    year = {2007}
}

@inproceedings{Ryzhyk2007Reliable,
    abstract = {{Current operating systems lack well-defined protocols for interaction with device drivers. We argue that this hinders the development of reliable drivers and thereby undermines overall system stability. We present an approach to specify driver protocols using a formalism based on state machines. We show that it can simplify device programming, facilitate static analysis of drivers against protocol specifications, and enable detection of incorrect behaviours at runtime.}},
    address = {Berkeley, CA, USA},
    author = {Ryzhyk, Leonid and Bourke, Timothy and Kuz, Ihor},
    booktitle = {HotDep'07: Proceedings of the 3rd workshop on on Hot Topics in System Dependability},
    citeulike-article-id = {3501916},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=1323143},
    keywords = {device\_driver, research\_progress, system\_os, verification},
    location = {Edinburgh, UK},
    posted-at = {2010-11-30 05:21:05},
    priority = {0},
    publisher = {USENIX Association},
    title = {{Reliable device drivers require well-defined protocols}},
    url = {http://portal.acm.org/citation.cfm?id=1323143},
    year = {2007}
}

@inproceedings{Rui2007Implementing,
    abstract = {{Contemporary software systems often provide mechanisms for extendingfunctionalities, which imposes great safety concerns on thewell-being of critical infrastructures. ATS is a recently developedlanguage with its type system rooted in Applied Type System framework(Xi 2004) which combines linear and dependent type theoriesfor enforcing safe use of resources at low-level. In this paper,we describe a framework for constructing reliable Linux devicedrivers in ATS. Specically, drivers are written and type checkedin ATS, then compiled and linked to kernel with safety guarantee.Our preliminary experience shows that this approach can effectivelyenhance the reliability of device drivers and save the testing/debugging time.}},
    author = {Rui, Shi},
    citeulike-article-id = {8331703},
    comment = {paper\_depo/LDD-plpv07.pdf

One future work:
One impediment is the type (proof) annotations burden imposed
on programmers, which seems inevitable if formal reasoning of
nontrivial safety properties is desired. Recently, we have been investigating
techniques for automatically inferring a large portion
of proofs to reduce the burden. We hope these techniques could
greatly facilitate the construction of more reliable OS components
as well in the future.
---=note-separator=---
Top-3 contributions of the paper:

Most glaring problems:

What could be improved:

What are the implications for the Research community:
},
    keywords = {programming\_language, system\_os, verification},
    posted-at = {2010-11-30 05:19:58},
    priority = {5},
    title = {{Implementing Reliable Linux Device Drivers in ATS}},
    year = {2007}
}

@article{GrahamHutto1998Monadic,
    abstract = {{This paper is a tutorial on defining recursive descent parsers in Haskell. In the spirit of one-stop shopping, the paper combines material from three areas into a single source. The three areas are functional parsers (Burge, 1975; Wadler, 1985; Hutton, 1992; Fokker, 1995), the use of monads to structure functional programs (Wadler, 1990, 1992a, 1992b), and the use of special syntax for monadic programs in Haskell (Jones, 1995; Peterson et al., 1996). More specifically, the paper shows how to define monadic parsers using do notation in Haskell.Of course, recursive descent parsers defined by hand lack the efficiency of bottom-up parsers generated by machine (Aho et al., 1986; Mogensen, 1993; Gill and Marlow, 1995). However, for many research applications, a simple recursive descent parser is perfectly sufficient. Moreover, while parser generators typically offer a fixed set of combinators for describing grammars, the method described here is completely extensible: parsers are first-class values, and we have the full power of Haskell available to define new combinators for special applications. The method is also an excellent illustration of the elegance of functional programming.}},
    author = {Graham Hutto, N. and Erik Meije, R.},
    citeulike-article-id = {5231842},
    citeulike-linkout-0 = {http://dx.doi.org/10.1017/S0956796898003050},
    citeulike-linkout-1 = {http://journals.cambridge.org/action/displayAbstract?fromPage=online\&aid=44175},
    comment = {paper\_demo/pearl.pdf},
    doi = {10.1017/S0956796898003050},
    journal = {Journal of Functional Programming},
    keywords = {programming\_language},
    number = {04},
    pages = {437--444},
    posted-at = {2010-11-15 22:38:02},
    priority = {2},
    title = {{Monadic parsing in Haskell}},
    url = {http://dx.doi.org/10.1017/S0956796898003050},
    volume = {8},
    year = {1998}
}

@electronic{Hutton1993HigherOrder,
    abstract = {{In combinator parsing, the text of parsers resembles BNF notation. We present the basic method, and a number of extensions. We address the special problems presented by white-- space, and parsers with separate lexical and syntactic phases. In particular, a combining form for handling the \&\#034;offside rule\&\#034; is given. Other extensions to the basic method include an \&\#034;into\&\#034; combining form with many useful applications, and a simple means by which combinator parsers can produce more informative error messages.  1 Introduction  Broadly speaking, a parser may be defined as a program which analyses text to determine its logical structure. For example, the parsing phase in a compiler takes a program text, and produces a parse tree which expounds the structure of the program. Many programs can be improved by having their input parsed. The form of input which is acceptable is usually defined by a context--free grammar, using BNF notation. Parsers themselves may be built by hand, but are most often ge...}},
    author = {Hutton, Graham},
    citeulike-article-id = {8251384},
    citeulike-linkout-0 = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.34.1287},
    comment = {paper\_depo/parsing.pdf},
    keywords = {programming\_language},
    posted-at = {2010-11-15 22:35:20},
    priority = {2},
    title = {{Higher-Order Functions for parsing}},
    url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.34.1287},
    year = {1993}
}

@electronic{KleinFormally,
    abstract = {{Abstract. Last year, the L4.verified project produced a formal, machinechecked Isabelle/HOL proof that the C code of the seL4 OS microkernel correctly implements its abstract implementation. In my presentation I will summarise the proof together with its main implications and assumptions, I will describe in which kinds of systems this formally verified kernel can be used for gaining assurance on overall system security, and I will explore further future research directions that open up with a formally verified OS kernel. 1 A Formally Verified OS Kernel Last year, we reported on the full formal verification of the seL4 microkernel from a high-level model down to very low-level C code [5]. To build a truly trustworthy system, one needs to start at the operating system (OS) and the most critical part of the OS is its kernel. The kernel is defined as the software that executes in the privileged mode of the hardware, meaning that there can be no protection from faults occurring in the kernel,}},
    author = {Klein, Gerwin},
    citeulike-article-id = {8239442},
    citeulike-linkout-0 = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.172.6413},
    keywords = {system\_os, verification},
    posted-at = {2010-11-11 21:14:18},
    priority = {2},
    title = {{A Formally Verified OS Kernel. Now What?}},
    url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.172.6413}
}

@inproceedings{Liu2006Mining,
    abstract = {{Frequent itemset mining is a popular and important first step in the analysis of data arising in a broad range of applications. The traditional  ” exact ” model for frequent itemsets requires that every item occur in each supporting transaction. However, real data is typically subject to noise and measurement error. To date, the effect of noise on exact frequent pattern mining algorithms have been addressed primarily through simulation studies, and there has been limited attention to the development of noise tolerant algorithms. In this paper we propose a noise tolerant itemset model, which we call approximate frequent itemsets (AFI). Like frequent itemsets, the AFI model requires that an itemset has a minimum number of supporting transactions. However,}},
    author = {Liu, Jinze and Paulsen, Susan and Sun, Xing and Wang, Wei and Nobel, Andrew and Prins, Jan},
    booktitle = {In Proceedings of the 6th SIAM Conference on Data Mining (SDM},
    citeulike-article-id = {8156804},
    citeulike-linkout-0 = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.62.3805},
    comment = {paper\_depo/SDM06.pdf},
    pages = {405--416},
    posted-at = {2010-11-01 00:18:23},
    priority = {0},
    title = {{Mining approximate frequent itemsets in the presence of noise: Algorithm and analysis}},
    url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.62.3805},
    volume = {405},
    year = {2006}
}

@article{Wu2008Mining,
    abstract = {{Real-world data mining deals with noisy information sources where data collection inaccuracy, device limitations, data transmission and discretization errors, or man-made perturbations frequently result in imprecise or vague data. Two common practices are to adopt either data cleansing approaches to enhance the data consistency or simply take noisy data as quality sources and feed them into the data mining algorithms. Either way may substantially sacrifice the mining performance. In this paper, we consider an error-aware (EA) data mining design, which takes advantage of statistical error information (such as noise level and noise distribution) to improve data mining results. We assume that such noise knowledge is available in advance, and we propose a solution to incorporate it into the mining process. More specifically, we use noise knowledge to restore original data distributions, which are further used to rectify the model built from noise- corrupted data. We materialize this concept by the proposed EA naive Bayes classification algorithm. Experimental comparisons on real-world datasets will demonstrate the effectiveness of this design.}},
    author = {Wu, Xindong and Zhu, Xingquan},
    citeulike-article-id = {8156796},
    citeulike-linkout-0 = {http://dx.doi.org/10.1109/TSMCA.2008.923034},
    citeulike-linkout-1 = {http://ieeexplore.ieee.org/xpls/abs\_all.jsp?arnumber=4544889},
    doi = {10.1109/TSMCA.2008.923034},
    issn = {1083-4427},
    journal = {IEEE Transactions on Systems, Man, and Cybernetics - Part A: Systems and Humans},
    keywords = {data\_mining},
    month = jul,
    number = {4},
    pages = {917--932},
    posted-at = {2010-11-01 00:15:11},
    priority = {0},
    title = {{Mining With Noise Knowledge: Error-Aware Data Mining}},
    url = {http://dx.doi.org/10.1109/TSMCA.2008.923034},
    volume = {38},
    year = {2008}
}

@electronic{Yang2003Learning,
    abstract = {{Classification is one of the major tasks in knowledge discovery and data mining. Naive Bayes classifier, in spite of its simplicity, has proven surprisingly effective in many practical applications. In real datasets, noise is inevitable, because of the imprecision of measurement or privacy preserving mechanisms. In this paper, we develop a new approach, LinEar-Equation-based noise-aWare bAYes classifier (LEEWAY), for learning the underlying naive Bayes classifier from noisy observations. Using}},
    author = {Yang, Yirong and Xia, Yi and Chi, Yun and Muntz, Richard R.},
    citeulike-article-id = {8156680},
    citeulike-linkout-0 = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.58.7111},
    comment = {paper\_depo/1011587111.pdf},
    keywords = {data\_mining},
    posted-at = {2010-10-31 23:42:37},
    priority = {0},
    title = {{Learning Naive Bayes Classifier from Noisy Data }},
    url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.58.7111},
    year = {2003}
}

@article{yin:bugs,
    abstract = {{Software errors and vulnerabilities in core Internet routers have led to several high-profile attacks on the Internet infrastructure and numerous outages. Building an understanding of bugs in open-source router software is a first step towards addressing these problems. In this paper, we study router bugs found in two widely-used open-source router implementations. We evaluate the root cause of bugs, ease of diagnosis and detectability, ease of prevention and avoidance, and their effect on network behavior.}},
    address = {New York, NY, USA},
    author = {Yin, Zuoning and Caesar, Matthew and Zhou, Yuanyuan},
    citeulike-article-id = {7365027},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=1823844.1823849},
    citeulike-linkout-1 = {http://dx.doi.org/10.1145/1823844.1823849},
    comment = {paper\_demo/p34-yin.pdf},
    doi = {10.1145/1823844.1823849},
    issn = {0146-4833},
    journal = {ACM SIGCOMM Computer Communication Review},
    keywords = {network},
    month = jun,
    number = {3},
    pages = {34--40},
    posted-at = {2010-10-31 03:19:05},
    priority = {5},
    publisher = {ACM},
    title = {{Towards understanding bugs in open source router software}},
    url = {http://dx.doi.org/10.1145/1823844.1823849},
    volume = {40},
    year = {2010}
}

@electronic{JacobsVeriFast,
    abstract = {{Abstract. We propose an approach for the verification of imperative programs based on the tool-supported, interactive insertion of annotations into the source code. Annotations include routine preconditions and postconditions and loop invariants in a form of separation logic, as well as inductive datatype definitions and recursive function and predicate definitions to enable rich specifications. To enable verification of these rich specifications, annotations also include lemma routines, which are like ordinary routines of the programming language, except that it is checked that they do not have side-effects and that they terminate. Recursive lemma routines serve as inductive proofs that their precondition implies their postcondition. Verification proceeds by symbolic execution, using a separation logicbased representation of memory, and using first-order terms constrained by a first-order theory as symbolic data values. Data value queries are delegated to an SMT solver; since memory framing issues are eliminated from these queries and only well-behaved quantification is used, SMT solver queries perform much better than in verification condition based approaches. Annotation insertion is supported by an integrated development environment where the user may invoke the verification tool. If verification fails, the user can step through the symbolic execution trace and inspect the symbolic state at each step. Since verification typically takes less than a second, this enables an efficient iterative annotate-and-verify process. Furthermore, it is hoped that by offering proof technology in a form recognizable to programmers, the approach brings interactive program verification to a wider audience.}},
    author = {Jacobs, Bart and Smans, Jan and Piessens, Frank},
    citeulike-article-id = {7964723},
    citeulike-linkout-0 = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.169.6780},
    comment = {paper\_depo/10.1.1.169.6780.pdf},
    keywords = {programming\_language},
    posted-at = {2010-10-09 00:30:35},
    priority = {4},
    title = {{VeriFast: Imperative Programs as Proofs}},
    url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.169.6780}
}

@article{Chlipala2009Effective,
    abstract = {{We present a new approach for constructing and verifying higher-order, imperative programs using the Coq proof assistant. We build on the past work on the Ynot system, which is based on Hoare Type Theory. That original system was a proof of concept, where every program verification was accomplished via laborious manual proofs, with much code devoted to uninteresting low-level details. In this paper, we present a re-implementation of Ynot which makes it possible to implement fully-verified, higher-order imperative programs with reasonable proof burden. At the same time, our new system is implemented entirely in Coq source files, showcasing the versatility of that proof assistant as a platform for research on language design and verification. Both versions of the system have been evaluated with case studies in the verification of imperative data structures, such as hash tables with higher-order iterators. The verification burden in our new system is reduced by at least an order of magnitude compared to the old system, by replacing manual proof with automation. The core of the automation is a simplification procedure for implications in higher-order separation logic, with hooks that allow programmers to add domain-specific simplification rules.}},
    address = {New York, NY, USA},
    author = {Chlipala, Adam and Malecha, Gregory and Morrisett, Greg and Shinnar, Avraham and Wisnesky, Ryan},
    citeulike-article-id = {7964690},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=1631687.1596565},
    citeulike-linkout-1 = {http://dx.doi.org/10.1145/1631687.1596565},
    comment = {paper\_depo/p79-chlipala.pdf},
    doi = {10.1145/1631687.1596565},
    issn = {0362-1340},
    journal = {SIGPLAN Not.},
    keywords = {programming\_language},
    number = {9},
    pages = {79--90},
    posted-at = {2010-10-09 00:23:00},
    priority = {5},
    publisher = {ACM},
    title = {{Effective interactive proofs for higher-order imperative programs}},
    url = {http://dx.doi.org/10.1145/1631687.1596565},
    volume = {44},
    year = {2009}
}

@electronic{FilliatreCertification,
    abstract = {{We present the formal proofs of total correctness of three sorting algorithms in the Coq proof assistant, namely insertion sort, quicksort and heapsort. The implementations are imperative programs working in-place on a given array. Those developments demonstrate the usefulness of inductive types and higher-order logic in the process of software certification. They also show that the proof of rather complex algorithms may be done in a small amount of time -- only a few days for each development -- and without great difficulty.}},
    author = {Filli\^{a}tre, Jean-Christophe and Magaud, Nicolas},
    citeulike-article-id = {7964649},
    citeulike-linkout-0 = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.40.1927},
    comment = {paper\_depo/10.1.1.40.1927.pdf},
    keywords = {programming\_language},
    posted-at = {2010-10-09 00:14:21},
    priority = {4},
    title = {{Certification of Sorting Algorithms in the Coq System}},
    url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.40.1927}
}

@techreport{Tushkanova2009Specifying,
    abstract = {{This work investigates the question of automaticity of algorithm proofs, through the typical example of a sorting algorithm. The first part introduces two specification languages for Java programs. In the second part one of them is used to specify a sorting algorithm by selection. The suggested specifications are enhanced until obtaining a complete solution by the current automated theorem provers. This report is a part of Elena Tushkanova's diploma project (equivalent to a master thesis) entitled  ” Modular Specification of Object Oriented Programs” from the Yaroslavl State University, Russia, translated from Russian into English.}},
    author = {Tushkanova, Elena and Giorgetti, Alain and Kouchnarenko, Olga},
    citeulike-article-id = {7955780},
    citeulike-linkout-0 = {http://hal.archives-ouvertes.fr/docs/00/42/90/40/PDF/RR2009-03.pdf},
    comment = {paper\_depo/RR2009-03.pdf},
    institution = {University of Franche-Comte},
    keywords = {programming\_language},
    posted-at = {2010-10-07 17:37:18},
    priority = {0},
    title = {{Specifying and Proving a Sorting Algorithm}},
    url = {http://hal.archives-ouvertes.fr/docs/00/42/90/40/PDF/RR2009-03.pdf},
    year = {2009}
}

@misc{Julin_namingfacilities,
    abstract = {{Abstract ¨C TheMach 3.0 micro-kernel provides a foundation for the emulation of various operating systems with a combination of libraries andMach servers. We present a general-purpose naming facility to help construct such emulation systems by assembling many independent servers. This facility defines a set of standard interfaces for a uniformname spacewith uniformaccessmediation and a set of practical mechanisms to integrate servers into this name space, through prefix tables and ancillary servers supporting specialmount points. We then discuss the application of this facility to UNIX 4.3 BSD emulation, to a secure system with a centralized trusted name server, and to larger distributed systems.}},
    author = {Julin, Daniel P.},
    citeulike-article-id = {7943717},
    citeulike-linkout-0 = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.37.8641},
    posted-at = {2010-10-04 03:07:52},
    priority = {2},
    title = {{Naming Facilities for Operating System Emulation in Mach 3.0}},
    url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.37.8641}
}

@inproceedings{Cui05ats_a,
    author = {Cui, Sa and Donnelly, Kevin and Xi, Hongwei},
    booktitle = {of Lecture Notes in Computer Science},
    citeulike-article-id = {7943716},
    pages = {310--320},
    posted-at = {2010-10-04 03:07:52},
    priority = {2},
    publisher = {Springer},
    title = {{Ats: A language that combines programming with theorem proving}},
    year = {2005}
}

@article{Cheriton89decentralizinga,
    author = {Cheriton, David R. and Mann, Timothy P.},
    citeulike-article-id = {7943715},
    journal = {ACM Transactions on Computer Systems},
    pages = {147--183},
    posted-at = {2010-10-04 03:07:52},
    priority = {2},
    title = {{Decentralizing a Global Naming Service for Improved Performance and Fault Tolerance}},
    volume = {7},
    year = {1989}
}

@inproceedings{rebootsHardware,
    abstract = {{Patches to modern operating systems, including bug fixes and security updates, and the reboots and downtime they require, cause tremendous problems for system users and administrators. Dynamic update allows an operating system to be patched without the need for a reboot or other service interruption. We have taken the approach of building dynamic update functionality directly into an existing operating system, K42.}},
    address = {Berkeley, CA, USA},
    author = {Baumann, Andrew and Appavoo, Jonathan and Wisniewski, Robert W. and Da Silva, Dilma and Krieger, Orran and Heiser, Gernot},
    booktitle = {ATC'07: 2007 USENIX Annual Technical Conference on Proceedings of the USENIX Annual Technical Conference},
    citeulike-article-id = {7943714},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=1364411},
    location = {Santa Clara, CA},
    pages = {1--14},
    posted-at = {2010-10-04 03:07:52},
    priority = {4},
    publisher = {USENIX Association},
    title = {{Reboots are for hardware: challenges and solutions to updating an operating system on the fly}},
    url = {http://portal.acm.org/citation.cfm?id=1364411},
    year = {2007}
}

@electronic{krakatoa,
    abstract = {{We describe the basic structure of an environment for proving Java programs annotated with JML specications. Our method is generic with respect to the API, and thus well suited for JavaCard applets certication. It involves three distinct components: the Why tool, which computes proof obligations for a core imperative language annotated with pre- and post-conditions, the Coq proof assistant for modeling the program semantics and conducting the development of proofs, and nally the Krakatoa tool, a translator of our own, which reads the Java les and produces specications for Coq and a representation of the semantics of the Java program into Why's input language.}},
    author = {March, C. and Paulin-Mohring, C. and Urbain, X.},
    citeulike-article-id = {3426175},
    citeulike-linkout-0 = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.7.4458},
    posted-at = {2010-06-17 04:41:10},
    priority = {2},
    title = {{The Krakatoa Tool for Certication of Java/JavaCard Programs annotated in JML}},
    url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.7.4458}
}

@inproceedings{Baumann2007Reboots,
    abstract = {{Patches to modern operating systems, including bug fixes and security updates, and the reboots and downtime they require, cause tremendous problems for system users and administrators. Dynamic update allows an operating system to be patched without the need for a reboot or other service interruption. We have taken the approach of building dynamic update functionality directly into an existing operating system, K42.}},
    address = {Berkeley, CA, USA},
    author = {Baumann, Andrew and Appavoo, Jonathan and Wisniewski, Robert W. and Da Silva, Dilma and Krieger, Orran and Heiser, Gernot},
    booktitle = {ATC'07: 2007 USENIX Annual Technical Conference on Proceedings of the USENIX Annual Technical Conference},
    citeulike-article-id = {3811494},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=1364411},
    isbn = {999-8888-77-6},
    location = {Santa Clara, CA},
    pages = {1--14},
    posted-at = {2010-03-03 03:44:38},
    priority = {4},
    publisher = {USENIX Association},
    title = {{Reboots are for hardware: challenges and solutions to updating an operating system on the fly}},
    url = {http://portal.acm.org/citation.cfm?id=1364411},
    year = {2007}
}

@inproceedings{CaShLe2004,
    abstract = {{This paper presents DTrace, a new facility for dynamic instrumentation of production systems. DTrace features the ability to dynamically instrument both user-level and kernel-level software in a unified and absolutely safe fashion. When not explicitly enabled, DTrace has zero probe effect !`ª the system operates exactly as if DTrace were not present at all. DTrace allows for many tens of thousands of instrumentation points, with even the smallest of systems offering on the order of 30,000 such points in the kernel alone. We have developed a C-like high-level control language to describe the predicates and actions at a given point of instrumentation. The language features user-defined variables, including threadlocal variables and associative arrays. To eliminate the need for most postprocessing, the facility features a scalable mechanism for aggregating data and a mechanism for speculative tracing. DTrace has been integrated into the Solaris operating system and has been used to find serious systemic performance problems on production systems !`ª problems that could not be found using preexisting facilities.}},
    address = {Berkeley, CA, USA},
    author = {Cantrill, Bryan M. and Shapiro, Michael W. and Leventhal, Adam H.},
    booktitle = {Proceedings of USENIX 2004 Annual Technical Conference},
    citeulike-article-id = {6703701},
    citeulike-linkout-0 = {http://www.usenix.org/event/usenix04/tech/general/cantrill.html},
    location = {Boston, MA},
    pages = {15--28},
    posted-at = {2010-02-19 20:20:13},
    priority = {0},
    publisher = {USENIX Association},
    title = {{Dynamic instrumentation of production systems}},
    url = {http://www.usenix.org/event/usenix04/tech/general/cantrill.html},
    year = {2004}
}

@inproceedings{Trent00thesawmill,
    author = {Trent, Alain G. and Jaeger, Trent and Park, Yoonho and Liedtke, Jochen and Elphinstone, Kevin and Uhlig, Volkmar and Tidswell, Jonathon E. and Deller, Luke and Reuther, Lars},
    booktitle = {In 9th SIGOPS European Workshop},
    citeulike-article-id = {6703508},
    citeulike-linkout-0 = {http://ertos.nicta.com.au/publications/papers/Gefflaut\_JPLEUTDR\_00.pdf},
    comment = {Sawmill and L4 based Linux are different.},
    pages = {109--114},
    posted-at = {2010-02-19 19:34:16},
    priority = {0},
    title = {{The SawMill Multiserver Approach}},
    url = {http://ertos.nicta.com.au/publications/papers/Gefflaut\_JPLEUTDR\_00.pdf},
    year = {2000}
}

@phdthesis{Lazic1999Semantic,
    author = {Lazic, Ranko},
    citeulike-article-id = {11560189},
    citeulike-linkout-0 = {http://citeseer.uark.edu:8080/citeseerx/showciting;jsessionid=344C8C9F9CE25F2A4FE75DDD6362C072?cid=96955\&\#38;sort=recent},
    institution = {Oxford University Computing Laboratory},
    posted-at = {2012-10-27 01:23:53},
    priority = {2},
    title = {{A Semantic Study of Data Independence with Application to Model Checking}},
    url = {http://citeseer.uark.edu:8080/citeseerx/showciting;jsessionid=344C8C9F9CE25F2A4FE75DDD6362C072?cid=96955\&\#38;sort=recent},
    year = {1999}
}

